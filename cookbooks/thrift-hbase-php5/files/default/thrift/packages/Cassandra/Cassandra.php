<?php
/**
 * Autogenerated by Thrift Compiler (0.7.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
include_once $GLOBALS['THRIFT_ROOT'].'/Thrift.php';

include_once $GLOBALS['THRIFT_ROOT'].'/packages/cassandra/cassandra_types.php';

interface CassandraIf {
  public function login($auth_request);
  public function set_keyspace($keyspace);
  public function get($key, $column_path, $consistency_level);
  public function get_slice($key, $column_parent, $predicate, $consistency_level);
  public function get_count($key, $column_parent, $predicate, $consistency_level);
  public function multiget_slice($keys, $column_parent, $predicate, $consistency_level);
  public function multiget_count($keys, $column_parent, $predicate, $consistency_level);
  public function get_range_slices($column_parent, $predicate, $range, $consistency_level);
  public function get_indexed_slices($column_parent, $index_clause, $column_predicate, $consistency_level);
  public function insert($key, $column_parent, $column, $consistency_level);
  public function add($key, $column_parent, $column, $consistency_level);
  public function remove($key, $column_path, $timestamp, $consistency_level);
  public function remove_counter($key, $path, $consistency_level);
  public function batch_mutate($mutation_map, $consistency_level);
  public function truncate($cfname);
  public function describe_schema_versions();
  public function describe_keyspaces();
  public function describe_cluster_name();
  public function describe_version();
  public function describe_ring($keyspace);
  public function describe_partitioner();
  public function describe_snitch();
  public function describe_keyspace($keyspace);
  public function describe_splits($cfName, $start_token, $end_token, $keys_per_split);
  public function system_add_column_family($cf_def);
  public function system_drop_column_family($column_family);
  public function system_add_keyspace($ks_def);
  public function system_drop_keyspace($keyspace);
  public function system_update_keyspace($ks_def);
  public function system_update_column_family($cf_def);
  public function execute_cql_query($query, $compression);
}

class CassandraClient implements CassandraIf {
  protected $input_ = null;
  protected $output_ = null;

  protected $seqid_ = 0;

  public function __construct($input, $output=null) {
    $this->input_ = $input;
    $this->output_ = $output ? $output : $input;
  }

  public function login($auth_request)
  {
    $this->send_login($auth_request);
    $this->recv_login();
  }

  public function send_login($auth_request)
  {
    $args = new Cassandra_login_args();
    $args->auth_request = $auth_request;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'login', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('login'));
      $buff .= 'login';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_login()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_login_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_login_result();
      $result->read($this->input_);
    }
    if ($result->authnx !== null) {
      throw $result->authnx;
    }
    if ($result->authzx !== null) {
      throw $result->authzx;
    }
    return;
  }

  public function set_keyspace($keyspace)
  {
    $this->send_set_keyspace($keyspace);
    $this->recv_set_keyspace();
  }

  public function send_set_keyspace($keyspace)
  {
    $args = new Cassandra_set_keyspace_args();
    $args->keyspace = $keyspace;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'set_keyspace', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('set_keyspace'));
      $buff .= 'set_keyspace';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_set_keyspace()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_set_keyspace_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_set_keyspace_result();
      $result->read($this->input_);
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    return;
  }

  public function get($key, $column_path, $consistency_level)
  {
    $this->send_get($key, $column_path, $consistency_level);
    return $this->recv_get();
  }

  public function send_get($key, $column_path, $consistency_level)
  {
    $args = new Cassandra_get_args();
    $args->key = $key;
    $args->column_path = $column_path;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('get'));
      $buff .= 'get';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_get()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_get_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_get_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->nfe !== null) {
      throw $result->nfe;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new Exception("get failed: unknown result");
  }

  public function get_slice($key, $column_parent, $predicate, $consistency_level)
  {
    $this->send_get_slice($key, $column_parent, $predicate, $consistency_level);
    return $this->recv_get_slice();
  }

  public function send_get_slice($key, $column_parent, $predicate, $consistency_level)
  {
    $args = new Cassandra_get_slice_args();
    $args->key = $key;
    $args->column_parent = $column_parent;
    $args->predicate = $predicate;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_slice', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('get_slice'));
      $buff .= 'get_slice';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_get_slice()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_get_slice_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_get_slice_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new Exception("get_slice failed: unknown result");
  }

  public function get_count($key, $column_parent, $predicate, $consistency_level)
  {
    $this->send_get_count($key, $column_parent, $predicate, $consistency_level);
    return $this->recv_get_count();
  }

  public function send_get_count($key, $column_parent, $predicate, $consistency_level)
  {
    $args = new Cassandra_get_count_args();
    $args->key = $key;
    $args->column_parent = $column_parent;
    $args->predicate = $predicate;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_count', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('get_count'));
      $buff .= 'get_count';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_get_count()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_get_count_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_get_count_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new Exception("get_count failed: unknown result");
  }

  public function multiget_slice($keys, $column_parent, $predicate, $consistency_level)
  {
    $this->send_multiget_slice($keys, $column_parent, $predicate, $consistency_level);
    return $this->recv_multiget_slice();
  }

  public function send_multiget_slice($keys, $column_parent, $predicate, $consistency_level)
  {
    $args = new Cassandra_multiget_slice_args();
    $args->keys = $keys;
    $args->column_parent = $column_parent;
    $args->predicate = $predicate;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'multiget_slice', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('multiget_slice'));
      $buff .= 'multiget_slice';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_multiget_slice()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_multiget_slice_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_multiget_slice_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new Exception("multiget_slice failed: unknown result");
  }

  public function multiget_count($keys, $column_parent, $predicate, $consistency_level)
  {
    $this->send_multiget_count($keys, $column_parent, $predicate, $consistency_level);
    return $this->recv_multiget_count();
  }

  public function send_multiget_count($keys, $column_parent, $predicate, $consistency_level)
  {
    $args = new Cassandra_multiget_count_args();
    $args->keys = $keys;
    $args->column_parent = $column_parent;
    $args->predicate = $predicate;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'multiget_count', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('multiget_count'));
      $buff .= 'multiget_count';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_multiget_count()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_multiget_count_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_multiget_count_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new Exception("multiget_count failed: unknown result");
  }

  public function get_range_slices($column_parent, $predicate, $range, $consistency_level)
  {
    $this->send_get_range_slices($column_parent, $predicate, $range, $consistency_level);
    return $this->recv_get_range_slices();
  }

  public function send_get_range_slices($column_parent, $predicate, $range, $consistency_level)
  {
    $args = new Cassandra_get_range_slices_args();
    $args->column_parent = $column_parent;
    $args->predicate = $predicate;
    $args->range = $range;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_range_slices', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('get_range_slices'));
      $buff .= 'get_range_slices';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_get_range_slices()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_get_range_slices_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_get_range_slices_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new Exception("get_range_slices failed: unknown result");
  }

  public function get_indexed_slices($column_parent, $index_clause, $column_predicate, $consistency_level)
  {
    $this->send_get_indexed_slices($column_parent, $index_clause, $column_predicate, $consistency_level);
    return $this->recv_get_indexed_slices();
  }

  public function send_get_indexed_slices($column_parent, $index_clause, $column_predicate, $consistency_level)
  {
    $args = new Cassandra_get_indexed_slices_args();
    $args->column_parent = $column_parent;
    $args->index_clause = $index_clause;
    $args->column_predicate = $column_predicate;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_indexed_slices', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('get_indexed_slices'));
      $buff .= 'get_indexed_slices';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_get_indexed_slices()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_get_indexed_slices_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_get_indexed_slices_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new Exception("get_indexed_slices failed: unknown result");
  }

  public function insert($key, $column_parent, $column, $consistency_level)
  {
    $this->send_insert($key, $column_parent, $column, $consistency_level);
    $this->recv_insert();
  }

  public function send_insert($key, $column_parent, $column, $consistency_level)
  {
    $args = new Cassandra_insert_args();
    $args->key = $key;
    $args->column_parent = $column_parent;
    $args->column = $column;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'insert', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('insert'));
      $buff .= 'insert';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_insert()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_insert_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_insert_result();
      $result->read($this->input_);
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function add($key, $column_parent, $column, $consistency_level)
  {
    $this->send_add($key, $column_parent, $column, $consistency_level);
    $this->recv_add();
  }

  public function send_add($key, $column_parent, $column, $consistency_level)
  {
    $args = new Cassandra_add_args();
    $args->key = $key;
    $args->column_parent = $column_parent;
    $args->column = $column;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('add'));
      $buff .= 'add';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_add()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_add_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_add_result();
      $result->read($this->input_);
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function remove($key, $column_path, $timestamp, $consistency_level)
  {
    $this->send_remove($key, $column_path, $timestamp, $consistency_level);
    $this->recv_remove();
  }

  public function send_remove($key, $column_path, $timestamp, $consistency_level)
  {
    $args = new Cassandra_remove_args();
    $args->key = $key;
    $args->column_path = $column_path;
    $args->timestamp = $timestamp;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'remove', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('remove'));
      $buff .= 'remove';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_remove()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_remove_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_remove_result();
      $result->read($this->input_);
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function remove_counter($key, $path, $consistency_level)
  {
    $this->send_remove_counter($key, $path, $consistency_level);
    $this->recv_remove_counter();
  }

  public function send_remove_counter($key, $path, $consistency_level)
  {
    $args = new Cassandra_remove_counter_args();
    $args->key = $key;
    $args->path = $path;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'remove_counter', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('remove_counter'));
      $buff .= 'remove_counter';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_remove_counter()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_remove_counter_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_remove_counter_result();
      $result->read($this->input_);
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function batch_mutate($mutation_map, $consistency_level)
  {
    $this->send_batch_mutate($mutation_map, $consistency_level);
    $this->recv_batch_mutate();
  }

  public function send_batch_mutate($mutation_map, $consistency_level)
  {
    $args = new Cassandra_batch_mutate_args();
    $args->mutation_map = $mutation_map;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'batch_mutate', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('batch_mutate'));
      $buff .= 'batch_mutate';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_batch_mutate()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_batch_mutate_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_batch_mutate_result();
      $result->read($this->input_);
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function truncate($cfname)
  {
    $this->send_truncate($cfname);
    $this->recv_truncate();
  }

  public function send_truncate($cfname)
  {
    $args = new Cassandra_truncate_args();
    $args->cfname = $cfname;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'truncate', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('truncate'));
      $buff .= 'truncate';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_truncate()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_truncate_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_truncate_result();
      $result->read($this->input_);
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    return;
  }

  public function describe_schema_versions()
  {
    $this->send_describe_schema_versions();
    return $this->recv_describe_schema_versions();
  }

  public function send_describe_schema_versions()
  {
    $args = new Cassandra_describe_schema_versions_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_schema_versions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('describe_schema_versions'));
      $buff .= 'describe_schema_versions';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_describe_schema_versions()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_describe_schema_versions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_describe_schema_versions_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new Exception("describe_schema_versions failed: unknown result");
  }

  public function describe_keyspaces()
  {
    $this->send_describe_keyspaces();
    return $this->recv_describe_keyspaces();
  }

  public function send_describe_keyspaces()
  {
    $args = new Cassandra_describe_keyspaces_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_keyspaces', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('describe_keyspaces'));
      $buff .= 'describe_keyspaces';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_describe_keyspaces()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_describe_keyspaces_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_describe_keyspaces_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new Exception("describe_keyspaces failed: unknown result");
  }

  public function describe_cluster_name()
  {
    $this->send_describe_cluster_name();
    return $this->recv_describe_cluster_name();
  }

  public function send_describe_cluster_name()
  {
    $args = new Cassandra_describe_cluster_name_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_cluster_name', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('describe_cluster_name'));
      $buff .= 'describe_cluster_name';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_describe_cluster_name()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_describe_cluster_name_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_describe_cluster_name_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new Exception("describe_cluster_name failed: unknown result");
  }

  public function describe_version()
  {
    $this->send_describe_version();
    return $this->recv_describe_version();
  }

  public function send_describe_version()
  {
    $args = new Cassandra_describe_version_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_version', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('describe_version'));
      $buff .= 'describe_version';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_describe_version()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_describe_version_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_describe_version_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new Exception("describe_version failed: unknown result");
  }

  public function describe_ring($keyspace)
  {
    $this->send_describe_ring($keyspace);
    return $this->recv_describe_ring();
  }

  public function send_describe_ring($keyspace)
  {
    $args = new Cassandra_describe_ring_args();
    $args->keyspace = $keyspace;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_ring', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('describe_ring'));
      $buff .= 'describe_ring';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_describe_ring()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_describe_ring_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_describe_ring_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new Exception("describe_ring failed: unknown result");
  }

  public function describe_partitioner()
  {
    $this->send_describe_partitioner();
    return $this->recv_describe_partitioner();
  }

  public function send_describe_partitioner()
  {
    $args = new Cassandra_describe_partitioner_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_partitioner', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('describe_partitioner'));
      $buff .= 'describe_partitioner';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_describe_partitioner()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_describe_partitioner_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_describe_partitioner_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new Exception("describe_partitioner failed: unknown result");
  }

  public function describe_snitch()
  {
    $this->send_describe_snitch();
    return $this->recv_describe_snitch();
  }

  public function send_describe_snitch()
  {
    $args = new Cassandra_describe_snitch_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_snitch', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('describe_snitch'));
      $buff .= 'describe_snitch';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_describe_snitch()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_describe_snitch_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_describe_snitch_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new Exception("describe_snitch failed: unknown result");
  }

  public function describe_keyspace($keyspace)
  {
    $this->send_describe_keyspace($keyspace);
    return $this->recv_describe_keyspace();
  }

  public function send_describe_keyspace($keyspace)
  {
    $args = new Cassandra_describe_keyspace_args();
    $args->keyspace = $keyspace;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_keyspace', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('describe_keyspace'));
      $buff .= 'describe_keyspace';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_describe_keyspace()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_describe_keyspace_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_describe_keyspace_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->nfe !== null) {
      throw $result->nfe;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new Exception("describe_keyspace failed: unknown result");
  }

  public function describe_splits($cfName, $start_token, $end_token, $keys_per_split)
  {
    $this->send_describe_splits($cfName, $start_token, $end_token, $keys_per_split);
    return $this->recv_describe_splits();
  }

  public function send_describe_splits($cfName, $start_token, $end_token, $keys_per_split)
  {
    $args = new Cassandra_describe_splits_args();
    $args->cfName = $cfName;
    $args->start_token = $start_token;
    $args->end_token = $end_token;
    $args->keys_per_split = $keys_per_split;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_splits', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('describe_splits'));
      $buff .= 'describe_splits';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_describe_splits()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_describe_splits_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_describe_splits_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new Exception("describe_splits failed: unknown result");
  }

  public function system_add_column_family($cf_def)
  {
    $this->send_system_add_column_family($cf_def);
    return $this->recv_system_add_column_family();
  }

  public function send_system_add_column_family($cf_def)
  {
    $args = new Cassandra_system_add_column_family_args();
    $args->cf_def = $cf_def;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_add_column_family', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('system_add_column_family'));
      $buff .= 'system_add_column_family';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_system_add_column_family()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_system_add_column_family_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_system_add_column_family_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new Exception("system_add_column_family failed: unknown result");
  }

  public function system_drop_column_family($column_family)
  {
    $this->send_system_drop_column_family($column_family);
    return $this->recv_system_drop_column_family();
  }

  public function send_system_drop_column_family($column_family)
  {
    $args = new Cassandra_system_drop_column_family_args();
    $args->column_family = $column_family;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_drop_column_family', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('system_drop_column_family'));
      $buff .= 'system_drop_column_family';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_system_drop_column_family()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_system_drop_column_family_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_system_drop_column_family_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new Exception("system_drop_column_family failed: unknown result");
  }

  public function system_add_keyspace($ks_def)
  {
    $this->send_system_add_keyspace($ks_def);
    return $this->recv_system_add_keyspace();
  }

  public function send_system_add_keyspace($ks_def)
  {
    $args = new Cassandra_system_add_keyspace_args();
    $args->ks_def = $ks_def;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_add_keyspace', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('system_add_keyspace'));
      $buff .= 'system_add_keyspace';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_system_add_keyspace()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_system_add_keyspace_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_system_add_keyspace_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new Exception("system_add_keyspace failed: unknown result");
  }

  public function system_drop_keyspace($keyspace)
  {
    $this->send_system_drop_keyspace($keyspace);
    return $this->recv_system_drop_keyspace();
  }

  public function send_system_drop_keyspace($keyspace)
  {
    $args = new Cassandra_system_drop_keyspace_args();
    $args->keyspace = $keyspace;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_drop_keyspace', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('system_drop_keyspace'));
      $buff .= 'system_drop_keyspace';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_system_drop_keyspace()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_system_drop_keyspace_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_system_drop_keyspace_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new Exception("system_drop_keyspace failed: unknown result");
  }

  public function system_update_keyspace($ks_def)
  {
    $this->send_system_update_keyspace($ks_def);
    return $this->recv_system_update_keyspace();
  }

  public function send_system_update_keyspace($ks_def)
  {
    $args = new Cassandra_system_update_keyspace_args();
    $args->ks_def = $ks_def;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_update_keyspace', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('system_update_keyspace'));
      $buff .= 'system_update_keyspace';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_system_update_keyspace()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_system_update_keyspace_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_system_update_keyspace_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new Exception("system_update_keyspace failed: unknown result");
  }

  public function system_update_column_family($cf_def)
  {
    $this->send_system_update_column_family($cf_def);
    return $this->recv_system_update_column_family();
  }

  public function send_system_update_column_family($cf_def)
  {
    $args = new Cassandra_system_update_column_family_args();
    $args->cf_def = $cf_def;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_update_column_family', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('system_update_column_family'));
      $buff .= 'system_update_column_family';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_system_update_column_family()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_system_update_column_family_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_system_update_column_family_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new Exception("system_update_column_family failed: unknown result");
  }

  public function execute_cql_query($query, $compression)
  {
    $this->send_execute_cql_query($query, $compression);
    return $this->recv_execute_cql_query();
  }

  public function send_execute_cql_query($query, $compression)
  {
    $args = new Cassandra_execute_cql_query_args();
    $args->query = $query;
    $args->compression = $compression;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'execute_cql_query', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $buff = pack('N', (0x80010000 | TMessageType::CALL));
      $buff .= pack('N', strlen('execute_cql_query'));
      $buff .= 'execute_cql_query';
      $buff .= pack('N', $this->seqid_);
      $args->write($buff);
      $this->output_->write($buff);
      $this->output_->flush();
    }
  }

  public function recv_execute_cql_query()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Cassandra_execute_cql_query_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $ver = unpack('N', $this->input_->readAll(4));
      $ver = $ver[1];
      $mtype = $ver & 0xff;
      $ver = $ver & 0xffff0000;
      if ($ver != 0x80010000) throw new TProtocolException('Bad version identifier: '.$ver, TProtocolException::BAD_VERSION);
      $len = unpack('N', $this->input_->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      $fname = $this->input_->readAll($len);
      $val = unpack('N', $this->input_->readAll(4));
      $val = $val[1];
      if ($val > 0x7fffffff) {
        $val = 0 - (($val - 1) ^ 0xffffffff);
      }
      $rseqid = $val;
      $result = new Cassandra_execute_cql_query_result();
      $result->read($this->input_);
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new Exception("execute_cql_query failed: unknown result");
  }

}

// HELPER FUNCTIONS AND STRUCTURES

class Cassandra_login_args {
  static $_TSPEC;

  public $auth_request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'auth_request',
          'type' => TType::STRUCT,
          'class' => 'AuthenticationRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['auth_request'])) {
        $this->auth_request = $vals['auth_request'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_login_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->auth_request = new AuthenticationRequest();
            $xfer += $this->auth_request->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->auth_request !== null) {
      if (!is_object($this->auth_request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->auth_request->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_login_result {
  static $_TSPEC;

  public $authnx = null;
  public $authzx = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'authnx',
          'type' => TType::STRUCT,
          'class' => 'AuthenticationException',
          ),
        2 => array(
          'var' => 'authzx',
          'type' => TType::STRUCT,
          'class' => 'AuthorizationException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['authnx'])) {
        $this->authnx = $vals['authnx'];
      }
      if (isset($vals['authzx'])) {
        $this->authzx = $vals['authzx'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_login_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->authnx = new AuthenticationException();
            $xfer += $this->authnx->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->authzx = new AuthorizationException();
            $xfer += $this->authzx->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->authnx !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->authnx->write($output);
    }
    if ($this->authzx !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->authzx->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_set_keyspace_args {
  static $_TSPEC;

  public $keyspace = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keyspace',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keyspace'])) {
        $this->keyspace = $vals['keyspace'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_set_keyspace_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->keyspace = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->keyspace !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->keyspace));
      $output .= $this->keyspace;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_set_keyspace_result {
  static $_TSPEC;

  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_set_keyspace_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_get_args {
  static $_TSPEC;

  public $key = null;
  public $column_path = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_path',
          'type' => TType::STRUCT,
          'class' => 'ColumnPath',
          ),
        3 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['key'])) {
        $this->key = $vals['key'];
      }
      if (isset($vals['column_path'])) {
        $this->column_path = $vals['column_path'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_get_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->key = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->column_path = new ColumnPath();
            $xfer += $this->column_path->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->consistency_level = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->key !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->key));
      $output .= $this->key;
    }
    if ($this->column_path !== null) {
      if (!is_object($this->column_path)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->column_path->write($output);
    }
    if ($this->consistency_level !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 3);
      $output .= pack('N', $this->consistency_level);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_get_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $nfe = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => 'ColumnOrSuperColumn',
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'nfe',
          'type' => TType::STRUCT,
          'class' => 'NotFoundException',
          ),
        3 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => 'UnavailableException',
          ),
        4 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => 'TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['nfe'])) {
        $this->nfe = $vals['nfe'];
      }
      if (isset($vals['ue'])) {
        $this->ue = $vals['ue'];
      }
      if (isset($vals['te'])) {
        $this->te = $vals['te'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_get_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new ColumnOrSuperColumn();
            $xfer += $this->success->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->nfe = new NotFoundException();
            $xfer += $this->nfe->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->ue = new UnavailableException();
            $xfer += $this->ue->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->te = new TimedOutException();
            $xfer += $this->te->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 0);
      $xfer += $this->success->write($output);
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->nfe !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->nfe->write($output);
    }
    if ($this->ue !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->ue->write($output);
    }
    if ($this->te !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 4);
      $xfer += $this->te->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_get_slice_args {
  static $_TSPEC;

  public $key = null;
  public $column_parent = null;
  public $predicate = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => 'ColumnParent',
          ),
        3 => array(
          'var' => 'predicate',
          'type' => TType::STRUCT,
          'class' => 'SlicePredicate',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['key'])) {
        $this->key = $vals['key'];
      }
      if (isset($vals['column_parent'])) {
        $this->column_parent = $vals['column_parent'];
      }
      if (isset($vals['predicate'])) {
        $this->predicate = $vals['predicate'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_get_slice_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->key = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->column_parent = new ColumnParent();
            $xfer += $this->column_parent->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->predicate = new SlicePredicate();
            $xfer += $this->predicate->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->consistency_level = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->key !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->key));
      $output .= $this->key;
    }
    if ($this->column_parent !== null) {
      if (!is_object($this->column_parent)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->column_parent->write($output);
    }
    if ($this->predicate !== null) {
      if (!is_object($this->predicate)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->predicate->write($output);
    }
    if ($this->consistency_level !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 4);
      $output .= pack('N', $this->consistency_level);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_get_slice_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'ColumnOrSuperColumn',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => 'UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => 'TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['ue'])) {
        $this->ue = $vals['ue'];
      }
      if (isset($vals['te'])) {
        $this->te = $vals['te'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_get_slice_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size147 = 0;
            $_etype150 = unpack('c', $input->readAll(1));
            $_etype150 = $_etype150[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size147 = $val;
            for ($_i151 = 0; $_i151 < $_size147; ++$_i151)
            {
              $elem152 = null;
              $elem152 = new ColumnOrSuperColumn();
              $xfer += $elem152->read($input);
              $this->success []= $elem152;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ue = new UnavailableException();
            $xfer += $this->ue->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->te = new TimedOutException();
            $xfer += $this->te->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 0);
      {
        $output .= pack('c', TType::STRUCT);
        $output .= strrev(pack('l', count($this->success)));
        {
          foreach ($this->success as $iter153)
          {
            $xfer += $iter153->write($output);
          }
        }
      }
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->ue !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->ue->write($output);
    }
    if ($this->te !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->te->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_get_count_args {
  static $_TSPEC;

  public $key = null;
  public $column_parent = null;
  public $predicate = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => 'ColumnParent',
          ),
        3 => array(
          'var' => 'predicate',
          'type' => TType::STRUCT,
          'class' => 'SlicePredicate',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['key'])) {
        $this->key = $vals['key'];
      }
      if (isset($vals['column_parent'])) {
        $this->column_parent = $vals['column_parent'];
      }
      if (isset($vals['predicate'])) {
        $this->predicate = $vals['predicate'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_get_count_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->key = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->column_parent = new ColumnParent();
            $xfer += $this->column_parent->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->predicate = new SlicePredicate();
            $xfer += $this->predicate->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->consistency_level = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->key !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->key));
      $output .= $this->key;
    }
    if ($this->column_parent !== null) {
      if (!is_object($this->column_parent)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->column_parent->write($output);
    }
    if ($this->predicate !== null) {
      if (!is_object($this->predicate)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->predicate->write($output);
    }
    if ($this->consistency_level !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 4);
      $output .= pack('N', $this->consistency_level);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_get_count_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => 'UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => 'TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['ue'])) {
        $this->ue = $vals['ue'];
      }
      if (isset($vals['te'])) {
        $this->te = $vals['te'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_get_count_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->success = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ue = new UnavailableException();
            $xfer += $this->ue->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->te = new TimedOutException();
            $xfer += $this->te->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 0);
      $output .= pack('N', $this->success);
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->ue !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->ue->write($output);
    }
    if ($this->te !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->te->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_multiget_slice_args {
  static $_TSPEC;

  public $keys = null;
  public $column_parent = null;
  public $predicate = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keys',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => 'ColumnParent',
          ),
        3 => array(
          'var' => 'predicate',
          'type' => TType::STRUCT,
          'class' => 'SlicePredicate',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keys'])) {
        $this->keys = $vals['keys'];
      }
      if (isset($vals['column_parent'])) {
        $this->column_parent = $vals['column_parent'];
      }
      if (isset($vals['predicate'])) {
        $this->predicate = $vals['predicate'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_multiget_slice_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->keys = array();
            $_size154 = 0;
            $_etype157 = unpack('c', $input->readAll(1));
            $_etype157 = $_etype157[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size154 = $val;
            for ($_i158 = 0; $_i158 < $_size154; ++$_i158)
            {
              $elem159 = null;
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $elem159 = $input->readAll($len);
              $this->keys []= $elem159;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->column_parent = new ColumnParent();
            $xfer += $this->column_parent->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->predicate = new SlicePredicate();
            $xfer += $this->predicate->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->consistency_level = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->keys !== null) {
      if (!is_array($this->keys)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 1);
      {
        $output .= pack('c', TType::STRING);
        $output .= strrev(pack('l', count($this->keys)));
        {
          foreach ($this->keys as $iter160)
          {
            $output .= pack('N', strlen($iter160));
            $output .= $iter160;
          }
        }
      }
    }
    if ($this->column_parent !== null) {
      if (!is_object($this->column_parent)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->column_parent->write($output);
    }
    if ($this->predicate !== null) {
      if (!is_object($this->predicate)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->predicate->write($output);
    }
    if ($this->consistency_level !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 4);
      $output .= pack('N', $this->consistency_level);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_multiget_slice_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
              'type' => TType::STRUCT,
              'class' => 'ColumnOrSuperColumn',
              ),
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => 'UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => 'TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['ue'])) {
        $this->ue = $vals['ue'];
      }
      if (isset($vals['te'])) {
        $this->te = $vals['te'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_multiget_slice_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::MAP) {
            $this->success = array();
            $_size161 = 0;
            $_ktype162 = 0;
            $_vtype163 = 0;
            $_ktype162 = unpack('c', $input->readAll(1));
            $_ktype162 = $_ktype162[1];
            $_vtype163 = unpack('c', $input->readAll(1));
            $_vtype163 = $_vtype163[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size161 = $val;
            for ($_i165 = 0; $_i165 < $_size161; ++$_i165)
            {
              $key166 = '';
              $val167 = array();
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $key166 = $input->readAll($len);
              $val167 = array();
              $_size168 = 0;
              $_etype171 = unpack('c', $input->readAll(1));
              $_etype171 = $_etype171[1];
              $val = unpack('N', $input->readAll(4));
              $val = $val[1];
              if ($val > 0x7fffffff) {
                $val = 0 - (($val - 1) ^ 0xffffffff);
              }
              $_size168 = $val;
              for ($_i172 = 0; $_i172 < $_size168; ++$_i172)
              {
                $elem173 = null;
                $elem173 = new ColumnOrSuperColumn();
                $xfer += $elem173->read($input);
                $val167 []= $elem173;
              }
              $this->success[$key166] = $val167;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ue = new UnavailableException();
            $xfer += $this->ue->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->te = new TimedOutException();
            $xfer += $this->te->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::MAP);
      $output .= pack('n', 0);
      {
        $output .= pack('c', TType::STRING);
        $output .= pack('c', TType::LST);
        $output .= strrev(pack('l', count($this->success)));
        {
          foreach ($this->success as $kiter174 => $viter175)
          {
            $output .= pack('N', strlen($kiter174));
            $output .= $kiter174;
            {
              $output .= pack('c', TType::STRUCT);
              $output .= strrev(pack('l', count($viter175)));
              {
                foreach ($viter175 as $iter176)
                {
                  $xfer += $iter176->write($output);
                }
              }
            }
          }
        }
      }
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->ue !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->ue->write($output);
    }
    if ($this->te !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->te->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_multiget_count_args {
  static $_TSPEC;

  public $keys = null;
  public $column_parent = null;
  public $predicate = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keys',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => 'ColumnParent',
          ),
        3 => array(
          'var' => 'predicate',
          'type' => TType::STRUCT,
          'class' => 'SlicePredicate',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keys'])) {
        $this->keys = $vals['keys'];
      }
      if (isset($vals['column_parent'])) {
        $this->column_parent = $vals['column_parent'];
      }
      if (isset($vals['predicate'])) {
        $this->predicate = $vals['predicate'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_multiget_count_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->keys = array();
            $_size177 = 0;
            $_etype180 = unpack('c', $input->readAll(1));
            $_etype180 = $_etype180[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size177 = $val;
            for ($_i181 = 0; $_i181 < $_size177; ++$_i181)
            {
              $elem182 = null;
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $elem182 = $input->readAll($len);
              $this->keys []= $elem182;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->column_parent = new ColumnParent();
            $xfer += $this->column_parent->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->predicate = new SlicePredicate();
            $xfer += $this->predicate->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->consistency_level = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->keys !== null) {
      if (!is_array($this->keys)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 1);
      {
        $output .= pack('c', TType::STRING);
        $output .= strrev(pack('l', count($this->keys)));
        {
          foreach ($this->keys as $iter183)
          {
            $output .= pack('N', strlen($iter183));
            $output .= $iter183;
          }
        }
      }
    }
    if ($this->column_parent !== null) {
      if (!is_object($this->column_parent)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->column_parent->write($output);
    }
    if ($this->predicate !== null) {
      if (!is_object($this->predicate)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->predicate->write($output);
    }
    if ($this->consistency_level !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 4);
      $output .= pack('N', $this->consistency_level);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_multiget_count_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => 'UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => 'TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['ue'])) {
        $this->ue = $vals['ue'];
      }
      if (isset($vals['te'])) {
        $this->te = $vals['te'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_multiget_count_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::MAP) {
            $this->success = array();
            $_size184 = 0;
            $_ktype185 = 0;
            $_vtype186 = 0;
            $_ktype185 = unpack('c', $input->readAll(1));
            $_ktype185 = $_ktype185[1];
            $_vtype186 = unpack('c', $input->readAll(1));
            $_vtype186 = $_vtype186[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size184 = $val;
            for ($_i188 = 0; $_i188 < $_size184; ++$_i188)
            {
              $key189 = '';
              $val190 = 0;
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $key189 = $input->readAll($len);
              $val = unpack('N', $input->readAll(4));
              $val = $val[1];
              if ($val > 0x7fffffff) {
                $val = 0 - (($val - 1) ^ 0xffffffff);
              }
              $val190 = $val;
              $this->success[$key189] = $val190;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ue = new UnavailableException();
            $xfer += $this->ue->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->te = new TimedOutException();
            $xfer += $this->te->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::MAP);
      $output .= pack('n', 0);
      {
        $output .= pack('c', TType::STRING);
        $output .= pack('c', TType::I32);
        $output .= strrev(pack('l', count($this->success)));
        {
          foreach ($this->success as $kiter191 => $viter192)
          {
            $output .= pack('N', strlen($kiter191));
            $output .= $kiter191;
            $output .= pack('N', $viter192);
          }
        }
      }
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->ue !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->ue->write($output);
    }
    if ($this->te !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->te->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_get_range_slices_args {
  static $_TSPEC;

  public $column_parent = null;
  public $predicate = null;
  public $range = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => 'ColumnParent',
          ),
        2 => array(
          'var' => 'predicate',
          'type' => TType::STRUCT,
          'class' => 'SlicePredicate',
          ),
        3 => array(
          'var' => 'range',
          'type' => TType::STRUCT,
          'class' => 'KeyRange',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['column_parent'])) {
        $this->column_parent = $vals['column_parent'];
      }
      if (isset($vals['predicate'])) {
        $this->predicate = $vals['predicate'];
      }
      if (isset($vals['range'])) {
        $this->range = $vals['range'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_get_range_slices_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->column_parent = new ColumnParent();
            $xfer += $this->column_parent->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->predicate = new SlicePredicate();
            $xfer += $this->predicate->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->range = new KeyRange();
            $xfer += $this->range->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->consistency_level = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->column_parent !== null) {
      if (!is_object($this->column_parent)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->column_parent->write($output);
    }
    if ($this->predicate !== null) {
      if (!is_object($this->predicate)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->predicate->write($output);
    }
    if ($this->range !== null) {
      if (!is_object($this->range)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->range->write($output);
    }
    if ($this->consistency_level !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 4);
      $output .= pack('N', $this->consistency_level);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_get_range_slices_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'KeySlice',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => 'UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => 'TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['ue'])) {
        $this->ue = $vals['ue'];
      }
      if (isset($vals['te'])) {
        $this->te = $vals['te'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_get_range_slices_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size193 = 0;
            $_etype196 = unpack('c', $input->readAll(1));
            $_etype196 = $_etype196[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size193 = $val;
            for ($_i197 = 0; $_i197 < $_size193; ++$_i197)
            {
              $elem198 = null;
              $elem198 = new KeySlice();
              $xfer += $elem198->read($input);
              $this->success []= $elem198;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ue = new UnavailableException();
            $xfer += $this->ue->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->te = new TimedOutException();
            $xfer += $this->te->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 0);
      {
        $output .= pack('c', TType::STRUCT);
        $output .= strrev(pack('l', count($this->success)));
        {
          foreach ($this->success as $iter199)
          {
            $xfer += $iter199->write($output);
          }
        }
      }
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->ue !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->ue->write($output);
    }
    if ($this->te !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->te->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_get_indexed_slices_args {
  static $_TSPEC;

  public $column_parent = null;
  public $index_clause = null;
  public $column_predicate = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => 'ColumnParent',
          ),
        2 => array(
          'var' => 'index_clause',
          'type' => TType::STRUCT,
          'class' => 'IndexClause',
          ),
        3 => array(
          'var' => 'column_predicate',
          'type' => TType::STRUCT,
          'class' => 'SlicePredicate',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['column_parent'])) {
        $this->column_parent = $vals['column_parent'];
      }
      if (isset($vals['index_clause'])) {
        $this->index_clause = $vals['index_clause'];
      }
      if (isset($vals['column_predicate'])) {
        $this->column_predicate = $vals['column_predicate'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_get_indexed_slices_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->column_parent = new ColumnParent();
            $xfer += $this->column_parent->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->index_clause = new IndexClause();
            $xfer += $this->index_clause->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->column_predicate = new SlicePredicate();
            $xfer += $this->column_predicate->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->consistency_level = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->column_parent !== null) {
      if (!is_object($this->column_parent)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->column_parent->write($output);
    }
    if ($this->index_clause !== null) {
      if (!is_object($this->index_clause)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->index_clause->write($output);
    }
    if ($this->column_predicate !== null) {
      if (!is_object($this->column_predicate)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->column_predicate->write($output);
    }
    if ($this->consistency_level !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 4);
      $output .= pack('N', $this->consistency_level);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_get_indexed_slices_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'KeySlice',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => 'UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => 'TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['ue'])) {
        $this->ue = $vals['ue'];
      }
      if (isset($vals['te'])) {
        $this->te = $vals['te'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_get_indexed_slices_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size200 = 0;
            $_etype203 = unpack('c', $input->readAll(1));
            $_etype203 = $_etype203[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size200 = $val;
            for ($_i204 = 0; $_i204 < $_size200; ++$_i204)
            {
              $elem205 = null;
              $elem205 = new KeySlice();
              $xfer += $elem205->read($input);
              $this->success []= $elem205;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ue = new UnavailableException();
            $xfer += $this->ue->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->te = new TimedOutException();
            $xfer += $this->te->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 0);
      {
        $output .= pack('c', TType::STRUCT);
        $output .= strrev(pack('l', count($this->success)));
        {
          foreach ($this->success as $iter206)
          {
            $xfer += $iter206->write($output);
          }
        }
      }
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->ue !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->ue->write($output);
    }
    if ($this->te !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->te->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_insert_args {
  static $_TSPEC;

  public $key = null;
  public $column_parent = null;
  public $column = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => 'ColumnParent',
          ),
        3 => array(
          'var' => 'column',
          'type' => TType::STRUCT,
          'class' => 'Column',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['key'])) {
        $this->key = $vals['key'];
      }
      if (isset($vals['column_parent'])) {
        $this->column_parent = $vals['column_parent'];
      }
      if (isset($vals['column'])) {
        $this->column = $vals['column'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_insert_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->key = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->column_parent = new ColumnParent();
            $xfer += $this->column_parent->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->column = new Column();
            $xfer += $this->column->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->consistency_level = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->key !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->key));
      $output .= $this->key;
    }
    if ($this->column_parent !== null) {
      if (!is_object($this->column_parent)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->column_parent->write($output);
    }
    if ($this->column !== null) {
      if (!is_object($this->column)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->column->write($output);
    }
    if ($this->consistency_level !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 4);
      $output .= pack('N', $this->consistency_level);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_insert_result {
  static $_TSPEC;

  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => 'UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => 'TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['ue'])) {
        $this->ue = $vals['ue'];
      }
      if (isset($vals['te'])) {
        $this->te = $vals['te'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_insert_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ue = new UnavailableException();
            $xfer += $this->ue->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->te = new TimedOutException();
            $xfer += $this->te->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->ue !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->ue->write($output);
    }
    if ($this->te !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->te->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_add_args {
  static $_TSPEC;

  public $key = null;
  public $column_parent = null;
  public $column = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => 'ColumnParent',
          ),
        3 => array(
          'var' => 'column',
          'type' => TType::STRUCT,
          'class' => 'CounterColumn',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['key'])) {
        $this->key = $vals['key'];
      }
      if (isset($vals['column_parent'])) {
        $this->column_parent = $vals['column_parent'];
      }
      if (isset($vals['column'])) {
        $this->column = $vals['column'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_add_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->key = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->column_parent = new ColumnParent();
            $xfer += $this->column_parent->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->column = new CounterColumn();
            $xfer += $this->column->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->consistency_level = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->key !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->key));
      $output .= $this->key;
    }
    if ($this->column_parent !== null) {
      if (!is_object($this->column_parent)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->column_parent->write($output);
    }
    if ($this->column !== null) {
      if (!is_object($this->column)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->column->write($output);
    }
    if ($this->consistency_level !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 4);
      $output .= pack('N', $this->consistency_level);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_add_result {
  static $_TSPEC;

  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => 'UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => 'TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['ue'])) {
        $this->ue = $vals['ue'];
      }
      if (isset($vals['te'])) {
        $this->te = $vals['te'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_add_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ue = new UnavailableException();
            $xfer += $this->ue->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->te = new TimedOutException();
            $xfer += $this->te->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->ue !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->ue->write($output);
    }
    if ($this->te !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->te->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_remove_args {
  static $_TSPEC;

  public $key = null;
  public $column_path = null;
  public $timestamp = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_path',
          'type' => TType::STRUCT,
          'class' => 'ColumnPath',
          ),
        3 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['key'])) {
        $this->key = $vals['key'];
      }
      if (isset($vals['column_path'])) {
        $this->column_path = $vals['column_path'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_remove_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->key = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->column_path = new ColumnPath();
            $xfer += $this->column_path->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $arr = unpack('N2', $input->readAll(8));
            if ($arr[1] & 0x80000000) {
              $arr[1] = $arr[1] ^ 0xFFFFFFFF;
              $arr[2] = $arr[2] ^ 0xFFFFFFFF;
              $this->timestamp = 0 - $arr[1]*4294967296 - $arr[2] - 1;
            } else {
              $this->timestamp = $arr[1]*4294967296 + $arr[2];
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->consistency_level = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->key !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->key));
      $output .= $this->key;
    }
    if ($this->column_path !== null) {
      if (!is_object($this->column_path)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->column_path->write($output);
    }
    if ($this->timestamp !== null) {
      $output .= pack('c', TType::I64);
      $output .= pack('n', 3);
      $output .= pack('N2', $this->timestamp >> 32, $this->timestamp & 0xFFFFFFFF);
    }
    if ($this->consistency_level !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 4);
      $output .= pack('N', $this->consistency_level);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_remove_result {
  static $_TSPEC;

  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => 'UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => 'TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['ue'])) {
        $this->ue = $vals['ue'];
      }
      if (isset($vals['te'])) {
        $this->te = $vals['te'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_remove_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ue = new UnavailableException();
            $xfer += $this->ue->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->te = new TimedOutException();
            $xfer += $this->te->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->ue !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->ue->write($output);
    }
    if ($this->te !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->te->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_remove_counter_args {
  static $_TSPEC;

  public $key = null;
  public $path = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'path',
          'type' => TType::STRUCT,
          'class' => 'ColumnPath',
          ),
        3 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['key'])) {
        $this->key = $vals['key'];
      }
      if (isset($vals['path'])) {
        $this->path = $vals['path'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_remove_counter_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->key = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->path = new ColumnPath();
            $xfer += $this->path->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->consistency_level = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->key !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->key));
      $output .= $this->key;
    }
    if ($this->path !== null) {
      if (!is_object($this->path)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->path->write($output);
    }
    if ($this->consistency_level !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 3);
      $output .= pack('N', $this->consistency_level);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_remove_counter_result {
  static $_TSPEC;

  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => 'UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => 'TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['ue'])) {
        $this->ue = $vals['ue'];
      }
      if (isset($vals['te'])) {
        $this->te = $vals['te'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_remove_counter_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ue = new UnavailableException();
            $xfer += $this->ue->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->te = new TimedOutException();
            $xfer += $this->te->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->ue !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->ue->write($output);
    }
    if ($this->te !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->te->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_batch_mutate_args {
  static $_TSPEC;

  public $mutation_map = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'mutation_map',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::MAP,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::MAP,
            'ktype' => TType::STRING,
            'vtype' => TType::LST,
            'key' => array(
              'type' => TType::STRING,
            ),
            'val' => array(
              'type' => TType::LST,
              'etype' => TType::STRUCT,
              'elem' => array(
                'type' => TType::STRUCT,
                'class' => 'Mutation',
                ),
              ),
            ),
          ),
        2 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['mutation_map'])) {
        $this->mutation_map = $vals['mutation_map'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_batch_mutate_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->mutation_map = array();
            $_size207 = 0;
            $_ktype208 = 0;
            $_vtype209 = 0;
            $_ktype208 = unpack('c', $input->readAll(1));
            $_ktype208 = $_ktype208[1];
            $_vtype209 = unpack('c', $input->readAll(1));
            $_vtype209 = $_vtype209[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size207 = $val;
            for ($_i211 = 0; $_i211 < $_size207; ++$_i211)
            {
              $key212 = '';
              $val213 = array();
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $key212 = $input->readAll($len);
              $val213 = array();
              $_size214 = 0;
              $_ktype215 = 0;
              $_vtype216 = 0;
              $_ktype215 = unpack('c', $input->readAll(1));
              $_ktype215 = $_ktype215[1];
              $_vtype216 = unpack('c', $input->readAll(1));
              $_vtype216 = $_vtype216[1];
              $val = unpack('N', $input->readAll(4));
              $val = $val[1];
              if ($val > 0x7fffffff) {
                $val = 0 - (($val - 1) ^ 0xffffffff);
              }
              $_size214 = $val;
              for ($_i218 = 0; $_i218 < $_size214; ++$_i218)
              {
                $key219 = '';
                $val220 = array();
                $len = unpack('N', $input->readAll(4));
                $len = $len[1];
                if ($len > 0x7fffffff) {
                  $len = 0 - (($len - 1) ^ 0xffffffff);
                }
                $key219 = $input->readAll($len);
                $val220 = array();
                $_size221 = 0;
                $_etype224 = unpack('c', $input->readAll(1));
                $_etype224 = $_etype224[1];
                $val = unpack('N', $input->readAll(4));
                $val = $val[1];
                if ($val > 0x7fffffff) {
                  $val = 0 - (($val - 1) ^ 0xffffffff);
                }
                $_size221 = $val;
                for ($_i225 = 0; $_i225 < $_size221; ++$_i225)
                {
                  $elem226 = null;
                  $elem226 = new Mutation();
                  $xfer += $elem226->read($input);
                  $val220 []= $elem226;
                }
                $val213[$key219] = $val220;
              }
              $this->mutation_map[$key212] = $val213;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->consistency_level = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->mutation_map !== null) {
      if (!is_array($this->mutation_map)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::MAP);
      $output .= pack('n', 1);
      {
        $output .= pack('c', TType::STRING);
        $output .= pack('c', TType::MAP);
        $output .= strrev(pack('l', count($this->mutation_map)));
        {
          foreach ($this->mutation_map as $kiter227 => $viter228)
          {
            $output .= pack('N', strlen($kiter227));
            $output .= $kiter227;
            {
              $output .= pack('c', TType::STRING);
              $output .= pack('c', TType::LST);
              $output .= strrev(pack('l', count($viter228)));
              {
                foreach ($viter228 as $kiter229 => $viter230)
                {
                  $output .= pack('N', strlen($kiter229));
                  $output .= $kiter229;
                  {
                    $output .= pack('c', TType::STRUCT);
                    $output .= strrev(pack('l', count($viter230)));
                    {
                      foreach ($viter230 as $iter231)
                      {
                        $xfer += $iter231->write($output);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if ($this->consistency_level !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 2);
      $output .= pack('N', $this->consistency_level);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_batch_mutate_result {
  static $_TSPEC;

  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => 'UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => 'TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['ue'])) {
        $this->ue = $vals['ue'];
      }
      if (isset($vals['te'])) {
        $this->te = $vals['te'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_batch_mutate_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ue = new UnavailableException();
            $xfer += $this->ue->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->te = new TimedOutException();
            $xfer += $this->te->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->ue !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->ue->write($output);
    }
    if ($this->te !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->te->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_truncate_args {
  static $_TSPEC;

  public $cfname = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cfname',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['cfname'])) {
        $this->cfname = $vals['cfname'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_truncate_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->cfname = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->cfname !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->cfname));
      $output .= $this->cfname;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_truncate_result {
  static $_TSPEC;

  public $ire = null;
  public $ue = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => 'UnavailableException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['ue'])) {
        $this->ue = $vals['ue'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_truncate_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ue = new UnavailableException();
            $xfer += $this->ue->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->ue !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->ue->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_schema_versions_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_schema_versions_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_schema_versions_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => array(
              'type' => TType::STRING,
              ),
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_describe_schema_versions_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::MAP) {
            $this->success = array();
            $_size232 = 0;
            $_ktype233 = 0;
            $_vtype234 = 0;
            $_ktype233 = unpack('c', $input->readAll(1));
            $_ktype233 = $_ktype233[1];
            $_vtype234 = unpack('c', $input->readAll(1));
            $_vtype234 = $_vtype234[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size232 = $val;
            for ($_i236 = 0; $_i236 < $_size232; ++$_i236)
            {
              $key237 = '';
              $val238 = array();
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $key237 = $input->readAll($len);
              $val238 = array();
              $_size239 = 0;
              $_etype242 = unpack('c', $input->readAll(1));
              $_etype242 = $_etype242[1];
              $val = unpack('N', $input->readAll(4));
              $val = $val[1];
              if ($val > 0x7fffffff) {
                $val = 0 - (($val - 1) ^ 0xffffffff);
              }
              $_size239 = $val;
              for ($_i243 = 0; $_i243 < $_size239; ++$_i243)
              {
                $elem244 = null;
                $len = unpack('N', $input->readAll(4));
                $len = $len[1];
                if ($len > 0x7fffffff) {
                  $len = 0 - (($len - 1) ^ 0xffffffff);
                }
                $elem244 = $input->readAll($len);
                $val238 []= $elem244;
              }
              $this->success[$key237] = $val238;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::MAP);
      $output .= pack('n', 0);
      {
        $output .= pack('c', TType::STRING);
        $output .= pack('c', TType::LST);
        $output .= strrev(pack('l', count($this->success)));
        {
          foreach ($this->success as $kiter245 => $viter246)
          {
            $output .= pack('N', strlen($kiter245));
            $output .= $kiter245;
            {
              $output .= pack('c', TType::STRING);
              $output .= strrev(pack('l', count($viter246)));
              {
                foreach ($viter246 as $iter247)
                {
                  $output .= pack('N', strlen($iter247));
                  $output .= $iter247;
                }
              }
            }
          }
        }
      }
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_keyspaces_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_keyspaces_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_keyspaces_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'KsDef',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_describe_keyspaces_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size248 = 0;
            $_etype251 = unpack('c', $input->readAll(1));
            $_etype251 = $_etype251[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size248 = $val;
            for ($_i252 = 0; $_i252 < $_size248; ++$_i252)
            {
              $elem253 = null;
              $elem253 = new KsDef();
              $xfer += $elem253->read($input);
              $this->success []= $elem253;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 0);
      {
        $output .= pack('c', TType::STRUCT);
        $output .= strrev(pack('l', count($this->success)));
        {
          foreach ($this->success as $iter254)
          {
            $xfer += $iter254->write($output);
          }
        }
      }
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_cluster_name_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_cluster_name_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_cluster_name_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_describe_cluster_name_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->success = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 0);
      $output .= pack('N', strlen($this->success));
      $output .= $this->success;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_version_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_version_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_version_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_describe_version_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->success = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 0);
      $output .= pack('N', strlen($this->success));
      $output .= $this->success;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_ring_args {
  static $_TSPEC;

  public $keyspace = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keyspace',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keyspace'])) {
        $this->keyspace = $vals['keyspace'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_describe_ring_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->keyspace = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->keyspace !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->keyspace));
      $output .= $this->keyspace;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_ring_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TokenRange',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_describe_ring_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size255 = 0;
            $_etype258 = unpack('c', $input->readAll(1));
            $_etype258 = $_etype258[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size255 = $val;
            for ($_i259 = 0; $_i259 < $_size255; ++$_i259)
            {
              $elem260 = null;
              $elem260 = new TokenRange();
              $xfer += $elem260->read($input);
              $this->success []= $elem260;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 0);
      {
        $output .= pack('c', TType::STRUCT);
        $output .= strrev(pack('l', count($this->success)));
        {
          foreach ($this->success as $iter261)
          {
            $xfer += $iter261->write($output);
          }
        }
      }
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_partitioner_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_partitioner_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_partitioner_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_describe_partitioner_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->success = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 0);
      $output .= pack('N', strlen($this->success));
      $output .= $this->success;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_snitch_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_snitch_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_snitch_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_describe_snitch_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->success = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 0);
      $output .= pack('N', strlen($this->success));
      $output .= $this->success;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_keyspace_args {
  static $_TSPEC;

  public $keyspace = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keyspace',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keyspace'])) {
        $this->keyspace = $vals['keyspace'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_describe_keyspace_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->keyspace = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->keyspace !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->keyspace));
      $output .= $this->keyspace;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_keyspace_result {
  static $_TSPEC;

  public $success = null;
  public $nfe = null;
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => 'KsDef',
          ),
        1 => array(
          'var' => 'nfe',
          'type' => TType::STRUCT,
          'class' => 'NotFoundException',
          ),
        2 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['nfe'])) {
        $this->nfe = $vals['nfe'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_describe_keyspace_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new KsDef();
            $xfer += $this->success->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->nfe = new NotFoundException();
            $xfer += $this->nfe->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 0);
      $xfer += $this->success->write($output);
    }
    if ($this->nfe !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->nfe->write($output);
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->ire->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_splits_args {
  static $_TSPEC;

  public $cfName = null;
  public $start_token = null;
  public $end_token = null;
  public $keys_per_split = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cfName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'start_token',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'end_token',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'keys_per_split',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['cfName'])) {
        $this->cfName = $vals['cfName'];
      }
      if (isset($vals['start_token'])) {
        $this->start_token = $vals['start_token'];
      }
      if (isset($vals['end_token'])) {
        $this->end_token = $vals['end_token'];
      }
      if (isset($vals['keys_per_split'])) {
        $this->keys_per_split = $vals['keys_per_split'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_describe_splits_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->cfName = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->start_token = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->end_token = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->keys_per_split = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->cfName !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->cfName));
      $output .= $this->cfName;
    }
    if ($this->start_token !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 2);
      $output .= pack('N', strlen($this->start_token));
      $output .= $this->start_token;
    }
    if ($this->end_token !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 3);
      $output .= pack('N', strlen($this->end_token));
      $output .= $this->end_token;
    }
    if ($this->keys_per_split !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 4);
      $output .= pack('N', $this->keys_per_split);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_describe_splits_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_describe_splits_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size262 = 0;
            $_etype265 = unpack('c', $input->readAll(1));
            $_etype265 = $_etype265[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size262 = $val;
            for ($_i266 = 0; $_i266 < $_size262; ++$_i266)
            {
              $elem267 = null;
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $elem267 = $input->readAll($len);
              $this->success []= $elem267;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 0);
      {
        $output .= pack('c', TType::STRING);
        $output .= strrev(pack('l', count($this->success)));
        {
          foreach ($this->success as $iter268)
          {
            $output .= pack('N', strlen($iter268));
            $output .= $iter268;
          }
        }
      }
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_system_add_column_family_args {
  static $_TSPEC;

  public $cf_def = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cf_def',
          'type' => TType::STRUCT,
          'class' => 'CfDef',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['cf_def'])) {
        $this->cf_def = $vals['cf_def'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_system_add_column_family_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->cf_def = new CfDef();
            $xfer += $this->cf_def->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->cf_def !== null) {
      if (!is_object($this->cf_def)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->cf_def->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_system_add_column_family_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => 'SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['sde'])) {
        $this->sde = $vals['sde'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_system_add_column_family_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->success = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->sde = new SchemaDisagreementException();
            $xfer += $this->sde->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 0);
      $output .= pack('N', strlen($this->success));
      $output .= $this->success;
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->sde !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->sde->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_system_drop_column_family_args {
  static $_TSPEC;

  public $column_family = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'column_family',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['column_family'])) {
        $this->column_family = $vals['column_family'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_system_drop_column_family_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->column_family = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->column_family !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->column_family));
      $output .= $this->column_family;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_system_drop_column_family_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => 'SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['sde'])) {
        $this->sde = $vals['sde'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_system_drop_column_family_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->success = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->sde = new SchemaDisagreementException();
            $xfer += $this->sde->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 0);
      $output .= pack('N', strlen($this->success));
      $output .= $this->success;
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->sde !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->sde->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_system_add_keyspace_args {
  static $_TSPEC;

  public $ks_def = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ks_def',
          'type' => TType::STRUCT,
          'class' => 'KsDef',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ks_def'])) {
        $this->ks_def = $vals['ks_def'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_system_add_keyspace_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ks_def = new KsDef();
            $xfer += $this->ks_def->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->ks_def !== null) {
      if (!is_object($this->ks_def)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ks_def->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_system_add_keyspace_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => 'SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['sde'])) {
        $this->sde = $vals['sde'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_system_add_keyspace_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->success = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->sde = new SchemaDisagreementException();
            $xfer += $this->sde->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 0);
      $output .= pack('N', strlen($this->success));
      $output .= $this->success;
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->sde !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->sde->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_system_drop_keyspace_args {
  static $_TSPEC;

  public $keyspace = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keyspace',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keyspace'])) {
        $this->keyspace = $vals['keyspace'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_system_drop_keyspace_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->keyspace = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->keyspace !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->keyspace));
      $output .= $this->keyspace;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_system_drop_keyspace_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => 'SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['sde'])) {
        $this->sde = $vals['sde'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_system_drop_keyspace_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->success = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->sde = new SchemaDisagreementException();
            $xfer += $this->sde->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 0);
      $output .= pack('N', strlen($this->success));
      $output .= $this->success;
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->sde !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->sde->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_system_update_keyspace_args {
  static $_TSPEC;

  public $ks_def = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ks_def',
          'type' => TType::STRUCT,
          'class' => 'KsDef',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ks_def'])) {
        $this->ks_def = $vals['ks_def'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_system_update_keyspace_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ks_def = new KsDef();
            $xfer += $this->ks_def->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->ks_def !== null) {
      if (!is_object($this->ks_def)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ks_def->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_system_update_keyspace_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => 'SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['sde'])) {
        $this->sde = $vals['sde'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_system_update_keyspace_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->success = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->sde = new SchemaDisagreementException();
            $xfer += $this->sde->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 0);
      $output .= pack('N', strlen($this->success));
      $output .= $this->success;
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->sde !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->sde->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_system_update_column_family_args {
  static $_TSPEC;

  public $cf_def = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cf_def',
          'type' => TType::STRUCT,
          'class' => 'CfDef',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['cf_def'])) {
        $this->cf_def = $vals['cf_def'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_system_update_column_family_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->cf_def = new CfDef();
            $xfer += $this->cf_def->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->cf_def !== null) {
      if (!is_object($this->cf_def)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->cf_def->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_system_update_column_family_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => 'SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['sde'])) {
        $this->sde = $vals['sde'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_system_update_column_family_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->success = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->sde = new SchemaDisagreementException();
            $xfer += $this->sde->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 0);
      $output .= pack('N', strlen($this->success));
      $output .= $this->success;
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->sde !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->sde->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_execute_cql_query_args {
  static $_TSPEC;

  public $query = null;
  public $compression = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'query',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'compression',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['query'])) {
        $this->query = $vals['query'];
      }
      if (isset($vals['compression'])) {
        $this->compression = $vals['compression'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_execute_cql_query_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->query = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->compression = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->query !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->query));
      $output .= $this->query;
    }
    if ($this->compression !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 2);
      $output .= pack('N', $this->compression);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Cassandra_execute_cql_query_result {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => 'CqlResult',
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => 'InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => 'UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => 'TimedOutException',
          ),
        4 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => 'SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ire'])) {
        $this->ire = $vals['ire'];
      }
      if (isset($vals['ue'])) {
        $this->ue = $vals['ue'];
      }
      if (isset($vals['te'])) {
        $this->te = $vals['te'];
      }
      if (isset($vals['sde'])) {
        $this->sde = $vals['sde'];
      }
    }
  }

  public function getName() {
    return 'Cassandra_execute_cql_query_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new CqlResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ire = new InvalidRequestException();
            $xfer += $this->ire->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ue = new UnavailableException();
            $xfer += $this->ue->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->te = new TimedOutException();
            $xfer += $this->te->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->sde = new SchemaDisagreementException();
            $xfer += $this->sde->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 0);
      $xfer += $this->success->write($output);
    }
    if ($this->ire !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->ire->write($output);
    }
    if ($this->ue !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->ue->write($output);
    }
    if ($this->te !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->te->write($output);
    }
    if ($this->sde !== null) {
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 4);
      $xfer += $this->sde->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

?>

