<?php
/**
 * Autogenerated by Thrift Compiler (0.7.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
include_once $GLOBALS['THRIFT_ROOT'].'/Thrift.php';


$GLOBALS['E_ConsistencyLevel'] = array(
  'ONE' => 1,
  'QUORUM' => 2,
  'LOCAL_QUORUM' => 3,
  'EACH_QUORUM' => 4,
  'ALL' => 5,
  'ANY' => 6,
  'TWO' => 7,
  'THREE' => 8,
);

final class ConsistencyLevel {
  const ONE = 1;
  const QUORUM = 2;
  const LOCAL_QUORUM = 3;
  const EACH_QUORUM = 4;
  const ALL = 5;
  const ANY = 6;
  const TWO = 7;
  const THREE = 8;
  static public $__names = array(
    1 => 'ONE',
    2 => 'QUORUM',
    3 => 'LOCAL_QUORUM',
    4 => 'EACH_QUORUM',
    5 => 'ALL',
    6 => 'ANY',
    7 => 'TWO',
    8 => 'THREE',
  );
}

$GLOBALS['E_IndexOperator'] = array(
  'EQ' => 0,
  'GTE' => 1,
  'GT' => 2,
  'LTE' => 3,
  'LT' => 4,
);

final class IndexOperator {
  const EQ = 0;
  const GTE = 1;
  const GT = 2;
  const LTE = 3;
  const LT = 4;
  static public $__names = array(
    0 => 'EQ',
    1 => 'GTE',
    2 => 'GT',
    3 => 'LTE',
    4 => 'LT',
  );
}

$GLOBALS['E_IndexType'] = array(
  'KEYS' => 0,
  'CUSTOM' => 1,
);

final class IndexType {
  const KEYS = 0;
  const CUSTOM = 1;
  static public $__names = array(
    0 => 'KEYS',
    1 => 'CUSTOM',
  );
}

$GLOBALS['E_Compression'] = array(
  'GZIP' => 1,
  'NONE' => 2,
);

final class Compression {
  const GZIP = 1;
  const NONE = 2;
  static public $__names = array(
    1 => 'GZIP',
    2 => 'NONE',
  );
}

$GLOBALS['E_CqlResultType'] = array(
  'ROWS' => 1,
  'VOID' => 2,
  'INT' => 3,
);

final class CqlResultType {
  const ROWS = 1;
  const VOID = 2;
  const INT = 3;
  static public $__names = array(
    1 => 'ROWS',
    2 => 'VOID',
    3 => 'INT',
  );
}

class Column {
  static $_TSPEC;

  public $name = null;
  public $value = null;
  public $timestamp = null;
  public $ttl = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'value',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'ttl',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
      if (isset($vals['ttl'])) {
        $this->ttl = $vals['ttl'];
      }
    }
  }

  public function getName() {
    return 'Column';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->name = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->value = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $arr = unpack('N2', $input->readAll(8));
            if ($arr[1] & 0x80000000) {
              $arr[1] = $arr[1] ^ 0xFFFFFFFF;
              $arr[2] = $arr[2] ^ 0xFFFFFFFF;
              $this->timestamp = 0 - $arr[1]*4294967296 - $arr[2] - 1;
            } else {
              $this->timestamp = $arr[1]*4294967296 + $arr[2];
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->ttl = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->name !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->name));
      $output .= $this->name;
    }
    if ($this->value !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 2);
      $output .= pack('N', strlen($this->value));
      $output .= $this->value;
    }
    if ($this->timestamp !== null) {
      $output .= pack('c', TType::I64);
      $output .= pack('n', 3);
      $output .= pack('N2', $this->timestamp >> 32, $this->timestamp & 0xFFFFFFFF);
    }
    if ($this->ttl !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 4);
      $output .= pack('N', $this->ttl);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class SuperColumn {
  static $_TSPEC;

  public $name = null;
  public $columns = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'Column',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
    }
  }

  public function getName() {
    return 'SuperColumn';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->name = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size0 = 0;
            $_etype3 = unpack('c', $input->readAll(1));
            $_etype3 = $_etype3[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size0 = $val;
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $elem5 = null;
              $elem5 = new Column();
              $xfer += $elem5->read($input);
              $this->columns []= $elem5;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->name !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->name));
      $output .= $this->name;
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 2);
      {
        $output .= pack('c', TType::STRUCT);
        $output .= strrev(pack('l', count($this->columns)));
        {
          foreach ($this->columns as $iter6)
          {
            $xfer += $iter6->write($output);
          }
        }
      }
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class CounterColumn {
  static $_TSPEC;

  public $name = null;
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'value',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'CounterColumn';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->name = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $arr = unpack('N2', $input->readAll(8));
            if ($arr[1] & 0x80000000) {
              $arr[1] = $arr[1] ^ 0xFFFFFFFF;
              $arr[2] = $arr[2] ^ 0xFFFFFFFF;
              $this->value = 0 - $arr[1]*4294967296 - $arr[2] - 1;
            } else {
              $this->value = $arr[1]*4294967296 + $arr[2];
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->name !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->name));
      $output .= $this->name;
    }
    if ($this->value !== null) {
      $output .= pack('c', TType::I64);
      $output .= pack('n', 2);
      $output .= pack('N2', $this->value >> 32, $this->value & 0xFFFFFFFF);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class CounterSuperColumn {
  static $_TSPEC;

  public $name = null;
  public $columns = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'CounterColumn',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
    }
  }

  public function getName() {
    return 'CounterSuperColumn';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->name = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size7 = 0;
            $_etype10 = unpack('c', $input->readAll(1));
            $_etype10 = $_etype10[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size7 = $val;
            for ($_i11 = 0; $_i11 < $_size7; ++$_i11)
            {
              $elem12 = null;
              $elem12 = new CounterColumn();
              $xfer += $elem12->read($input);
              $this->columns []= $elem12;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->name !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->name));
      $output .= $this->name;
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 2);
      {
        $output .= pack('c', TType::STRUCT);
        $output .= strrev(pack('l', count($this->columns)));
        {
          foreach ($this->columns as $iter13)
          {
            $xfer += $iter13->write($output);
          }
        }
      }
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class ColumnOrSuperColumn {
  static $_TSPEC;

  public $column = null;
  public $super_column = null;
  public $counter_column = null;
  public $counter_super_column = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'column',
          'type' => TType::STRUCT,
          'class' => 'Column',
          ),
        2 => array(
          'var' => 'super_column',
          'type' => TType::STRUCT,
          'class' => 'SuperColumn',
          ),
        3 => array(
          'var' => 'counter_column',
          'type' => TType::STRUCT,
          'class' => 'CounterColumn',
          ),
        4 => array(
          'var' => 'counter_super_column',
          'type' => TType::STRUCT,
          'class' => 'CounterSuperColumn',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['column'])) {
        $this->column = $vals['column'];
      }
      if (isset($vals['super_column'])) {
        $this->super_column = $vals['super_column'];
      }
      if (isset($vals['counter_column'])) {
        $this->counter_column = $vals['counter_column'];
      }
      if (isset($vals['counter_super_column'])) {
        $this->counter_super_column = $vals['counter_super_column'];
      }
    }
  }

  public function getName() {
    return 'ColumnOrSuperColumn';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->column = new Column();
            $xfer += $this->column->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->super_column = new SuperColumn();
            $xfer += $this->super_column->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->counter_column = new CounterColumn();
            $xfer += $this->counter_column->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->counter_super_column = new CounterSuperColumn();
            $xfer += $this->counter_super_column->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->column !== null) {
      if (!is_object($this->column)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->column->write($output);
    }
    if ($this->super_column !== null) {
      if (!is_object($this->super_column)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->super_column->write($output);
    }
    if ($this->counter_column !== null) {
      if (!is_object($this->counter_column)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->counter_column->write($output);
    }
    if ($this->counter_super_column !== null) {
      if (!is_object($this->counter_super_column)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 4);
      $xfer += $this->counter_super_column->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class NotFoundException extends TException {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'NotFoundException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class InvalidRequestException extends TException {
  static $_TSPEC;

  public $why = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'why',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['why'])) {
        $this->why = $vals['why'];
      }
    }
  }

  public function getName() {
    return 'InvalidRequestException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->why = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->why !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->why));
      $output .= $this->why;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class UnavailableException extends TException {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'UnavailableException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class TimedOutException extends TException {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'TimedOutException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class AuthenticationException extends TException {
  static $_TSPEC;

  public $why = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'why',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['why'])) {
        $this->why = $vals['why'];
      }
    }
  }

  public function getName() {
    return 'AuthenticationException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->why = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->why !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->why));
      $output .= $this->why;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class AuthorizationException extends TException {
  static $_TSPEC;

  public $why = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'why',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['why'])) {
        $this->why = $vals['why'];
      }
    }
  }

  public function getName() {
    return 'AuthorizationException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->why = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->why !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->why));
      $output .= $this->why;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class SchemaDisagreementException extends TException {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'SchemaDisagreementException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class ColumnParent {
  static $_TSPEC;

  public $column_family = null;
  public $super_column = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        3 => array(
          'var' => 'column_family',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'super_column',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['column_family'])) {
        $this->column_family = $vals['column_family'];
      }
      if (isset($vals['super_column'])) {
        $this->super_column = $vals['super_column'];
      }
    }
  }

  public function getName() {
    return 'ColumnParent';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 3:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->column_family = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->super_column = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->column_family !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 3);
      $output .= pack('N', strlen($this->column_family));
      $output .= $this->column_family;
    }
    if ($this->super_column !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 4);
      $output .= pack('N', strlen($this->super_column));
      $output .= $this->super_column;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class ColumnPath {
  static $_TSPEC;

  public $column_family = null;
  public $super_column = null;
  public $column = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        3 => array(
          'var' => 'column_family',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'super_column',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'column',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['column_family'])) {
        $this->column_family = $vals['column_family'];
      }
      if (isset($vals['super_column'])) {
        $this->super_column = $vals['super_column'];
      }
      if (isset($vals['column'])) {
        $this->column = $vals['column'];
      }
    }
  }

  public function getName() {
    return 'ColumnPath';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 3:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->column_family = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->super_column = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->column = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->column_family !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 3);
      $output .= pack('N', strlen($this->column_family));
      $output .= $this->column_family;
    }
    if ($this->super_column !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 4);
      $output .= pack('N', strlen($this->super_column));
      $output .= $this->super_column;
    }
    if ($this->column !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 5);
      $output .= pack('N', strlen($this->column));
      $output .= $this->column;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class SliceRange {
  static $_TSPEC;

  public $start = null;
  public $finish = null;
  public $reversed = false;
  public $count = 100;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'start',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'finish',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'reversed',
          'type' => TType::BOOL,
          ),
        4 => array(
          'var' => 'count',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['start'])) {
        $this->start = $vals['start'];
      }
      if (isset($vals['finish'])) {
        $this->finish = $vals['finish'];
      }
      if (isset($vals['reversed'])) {
        $this->reversed = $vals['reversed'];
      }
      if (isset($vals['count'])) {
        $this->count = $vals['count'];
      }
    }
  }

  public function getName() {
    return 'SliceRange';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->start = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->finish = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $this->reversed = unpack('c', $input->readAll(1));
            $this->reversed = (bool)$this->reversed[1];
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->count = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->start !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->start));
      $output .= $this->start;
    }
    if ($this->finish !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 2);
      $output .= pack('N', strlen($this->finish));
      $output .= $this->finish;
    }
    if ($this->reversed !== null) {
      $output .= pack('c', TType::BOOL);
      $output .= pack('n', 3);
      $output .= pack('c', $this->reversed ? 1 : 0);
    }
    if ($this->count !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 4);
      $output .= pack('N', $this->count);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class SlicePredicate {
  static $_TSPEC;

  public $column_names = null;
  public $slice_range = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'column_names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'slice_range',
          'type' => TType::STRUCT,
          'class' => 'SliceRange',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['column_names'])) {
        $this->column_names = $vals['column_names'];
      }
      if (isset($vals['slice_range'])) {
        $this->slice_range = $vals['slice_range'];
      }
    }
  }

  public function getName() {
    return 'SlicePredicate';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->column_names = array();
            $_size14 = 0;
            $_etype17 = unpack('c', $input->readAll(1));
            $_etype17 = $_etype17[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size14 = $val;
            for ($_i18 = 0; $_i18 < $_size14; ++$_i18)
            {
              $elem19 = null;
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $elem19 = $input->readAll($len);
              $this->column_names []= $elem19;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->slice_range = new SliceRange();
            $xfer += $this->slice_range->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->column_names !== null) {
      if (!is_array($this->column_names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 1);
      {
        $output .= pack('c', TType::STRING);
        $output .= strrev(pack('l', count($this->column_names)));
        {
          foreach ($this->column_names as $iter20)
          {
            $output .= pack('N', strlen($iter20));
            $output .= $iter20;
          }
        }
      }
    }
    if ($this->slice_range !== null) {
      if (!is_object($this->slice_range)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->slice_range->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class IndexExpression {
  static $_TSPEC;

  public $column_name = null;
  public $op = null;
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'column_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'op',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'value',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['column_name'])) {
        $this->column_name = $vals['column_name'];
      }
      if (isset($vals['op'])) {
        $this->op = $vals['op'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'IndexExpression';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->column_name = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->op = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->value = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->column_name !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->column_name));
      $output .= $this->column_name;
    }
    if ($this->op !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 2);
      $output .= pack('N', $this->op);
    }
    if ($this->value !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 3);
      $output .= pack('N', strlen($this->value));
      $output .= $this->value;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class IndexClause {
  static $_TSPEC;

  public $expressions = null;
  public $start_key = null;
  public $count = 100;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'expressions',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'IndexExpression',
            ),
          ),
        2 => array(
          'var' => 'start_key',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'count',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['expressions'])) {
        $this->expressions = $vals['expressions'];
      }
      if (isset($vals['start_key'])) {
        $this->start_key = $vals['start_key'];
      }
      if (isset($vals['count'])) {
        $this->count = $vals['count'];
      }
    }
  }

  public function getName() {
    return 'IndexClause';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->expressions = array();
            $_size21 = 0;
            $_etype24 = unpack('c', $input->readAll(1));
            $_etype24 = $_etype24[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size21 = $val;
            for ($_i25 = 0; $_i25 < $_size21; ++$_i25)
            {
              $elem26 = null;
              $elem26 = new IndexExpression();
              $xfer += $elem26->read($input);
              $this->expressions []= $elem26;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->start_key = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->count = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->expressions !== null) {
      if (!is_array($this->expressions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 1);
      {
        $output .= pack('c', TType::STRUCT);
        $output .= strrev(pack('l', count($this->expressions)));
        {
          foreach ($this->expressions as $iter27)
          {
            $xfer += $iter27->write($output);
          }
        }
      }
    }
    if ($this->start_key !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 2);
      $output .= pack('N', strlen($this->start_key));
      $output .= $this->start_key;
    }
    if ($this->count !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 3);
      $output .= pack('N', $this->count);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class KeyRange {
  static $_TSPEC;

  public $start_key = null;
  public $end_key = null;
  public $start_token = null;
  public $end_token = null;
  public $count = 100;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'start_key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'end_key',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'start_token',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'end_token',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'count',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['start_key'])) {
        $this->start_key = $vals['start_key'];
      }
      if (isset($vals['end_key'])) {
        $this->end_key = $vals['end_key'];
      }
      if (isset($vals['start_token'])) {
        $this->start_token = $vals['start_token'];
      }
      if (isset($vals['end_token'])) {
        $this->end_token = $vals['end_token'];
      }
      if (isset($vals['count'])) {
        $this->count = $vals['count'];
      }
    }
  }

  public function getName() {
    return 'KeyRange';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->start_key = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->end_key = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->start_token = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->end_token = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->count = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->start_key !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->start_key));
      $output .= $this->start_key;
    }
    if ($this->end_key !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 2);
      $output .= pack('N', strlen($this->end_key));
      $output .= $this->end_key;
    }
    if ($this->start_token !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 3);
      $output .= pack('N', strlen($this->start_token));
      $output .= $this->start_token;
    }
    if ($this->end_token !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 4);
      $output .= pack('N', strlen($this->end_token));
      $output .= $this->end_token;
    }
    if ($this->count !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 5);
      $output .= pack('N', $this->count);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class KeySlice {
  static $_TSPEC;

  public $key = null;
  public $columns = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'ColumnOrSuperColumn',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['key'])) {
        $this->key = $vals['key'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
    }
  }

  public function getName() {
    return 'KeySlice';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->key = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size28 = 0;
            $_etype31 = unpack('c', $input->readAll(1));
            $_etype31 = $_etype31[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size28 = $val;
            for ($_i32 = 0; $_i32 < $_size28; ++$_i32)
            {
              $elem33 = null;
              $elem33 = new ColumnOrSuperColumn();
              $xfer += $elem33->read($input);
              $this->columns []= $elem33;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->key !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->key));
      $output .= $this->key;
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 2);
      {
        $output .= pack('c', TType::STRUCT);
        $output .= strrev(pack('l', count($this->columns)));
        {
          foreach ($this->columns as $iter34)
          {
            $xfer += $iter34->write($output);
          }
        }
      }
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class KeyCount {
  static $_TSPEC;

  public $key = null;
  public $count = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'count',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['key'])) {
        $this->key = $vals['key'];
      }
      if (isset($vals['count'])) {
        $this->count = $vals['count'];
      }
    }
  }

  public function getName() {
    return 'KeyCount';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->key = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->count = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->key !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->key));
      $output .= $this->key;
    }
    if ($this->count !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 2);
      $output .= pack('N', $this->count);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Deletion {
  static $_TSPEC;

  public $timestamp = null;
  public $super_column = null;
  public $predicate = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'super_column',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'predicate',
          'type' => TType::STRUCT,
          'class' => 'SlicePredicate',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
      if (isset($vals['super_column'])) {
        $this->super_column = $vals['super_column'];
      }
      if (isset($vals['predicate'])) {
        $this->predicate = $vals['predicate'];
      }
    }
  }

  public function getName() {
    return 'Deletion';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $arr = unpack('N2', $input->readAll(8));
            if ($arr[1] & 0x80000000) {
              $arr[1] = $arr[1] ^ 0xFFFFFFFF;
              $arr[2] = $arr[2] ^ 0xFFFFFFFF;
              $this->timestamp = 0 - $arr[1]*4294967296 - $arr[2] - 1;
            } else {
              $this->timestamp = $arr[1]*4294967296 + $arr[2];
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->super_column = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->predicate = new SlicePredicate();
            $xfer += $this->predicate->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->timestamp !== null) {
      $output .= pack('c', TType::I64);
      $output .= pack('n', 1);
      $output .= pack('N2', $this->timestamp >> 32, $this->timestamp & 0xFFFFFFFF);
    }
    if ($this->super_column !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 2);
      $output .= pack('N', strlen($this->super_column));
      $output .= $this->super_column;
    }
    if ($this->predicate !== null) {
      if (!is_object($this->predicate)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 3);
      $xfer += $this->predicate->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class Mutation {
  static $_TSPEC;

  public $column_or_supercolumn = null;
  public $deletion = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'column_or_supercolumn',
          'type' => TType::STRUCT,
          'class' => 'ColumnOrSuperColumn',
          ),
        2 => array(
          'var' => 'deletion',
          'type' => TType::STRUCT,
          'class' => 'Deletion',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['column_or_supercolumn'])) {
        $this->column_or_supercolumn = $vals['column_or_supercolumn'];
      }
      if (isset($vals['deletion'])) {
        $this->deletion = $vals['deletion'];
      }
    }
  }

  public function getName() {
    return 'Mutation';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->column_or_supercolumn = new ColumnOrSuperColumn();
            $xfer += $this->column_or_supercolumn->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->deletion = new Deletion();
            $xfer += $this->deletion->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->column_or_supercolumn !== null) {
      if (!is_object($this->column_or_supercolumn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 1);
      $xfer += $this->column_or_supercolumn->write($output);
    }
    if ($this->deletion !== null) {
      if (!is_object($this->deletion)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 2);
      $xfer += $this->deletion->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class EndpointDetails {
  static $_TSPEC;

  public $host = null;
  public $datacenter = null;
  public $rack = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'host',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'datacenter',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'rack',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['host'])) {
        $this->host = $vals['host'];
      }
      if (isset($vals['datacenter'])) {
        $this->datacenter = $vals['datacenter'];
      }
      if (isset($vals['rack'])) {
        $this->rack = $vals['rack'];
      }
    }
  }

  public function getName() {
    return 'EndpointDetails';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->host = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->datacenter = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->rack = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->host !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->host));
      $output .= $this->host;
    }
    if ($this->datacenter !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 2);
      $output .= pack('N', strlen($this->datacenter));
      $output .= $this->datacenter;
    }
    if ($this->rack !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 3);
      $output .= pack('N', strlen($this->rack));
      $output .= $this->rack;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class TokenRange {
  static $_TSPEC;

  public $start_token = null;
  public $end_token = null;
  public $endpoints = null;
  public $rpc_endpoints = null;
  public $endpoint_details = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'start_token',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'end_token',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'endpoints',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'rpc_endpoints',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'endpoint_details',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'EndpointDetails',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['start_token'])) {
        $this->start_token = $vals['start_token'];
      }
      if (isset($vals['end_token'])) {
        $this->end_token = $vals['end_token'];
      }
      if (isset($vals['endpoints'])) {
        $this->endpoints = $vals['endpoints'];
      }
      if (isset($vals['rpc_endpoints'])) {
        $this->rpc_endpoints = $vals['rpc_endpoints'];
      }
      if (isset($vals['endpoint_details'])) {
        $this->endpoint_details = $vals['endpoint_details'];
      }
    }
  }

  public function getName() {
    return 'TokenRange';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->start_token = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->end_token = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->endpoints = array();
            $_size35 = 0;
            $_etype38 = unpack('c', $input->readAll(1));
            $_etype38 = $_etype38[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size35 = $val;
            for ($_i39 = 0; $_i39 < $_size35; ++$_i39)
            {
              $elem40 = null;
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $elem40 = $input->readAll($len);
              $this->endpoints []= $elem40;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->rpc_endpoints = array();
            $_size41 = 0;
            $_etype44 = unpack('c', $input->readAll(1));
            $_etype44 = $_etype44[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size41 = $val;
            for ($_i45 = 0; $_i45 < $_size41; ++$_i45)
            {
              $elem46 = null;
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $elem46 = $input->readAll($len);
              $this->rpc_endpoints []= $elem46;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->endpoint_details = array();
            $_size47 = 0;
            $_etype50 = unpack('c', $input->readAll(1));
            $_etype50 = $_etype50[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size47 = $val;
            for ($_i51 = 0; $_i51 < $_size47; ++$_i51)
            {
              $elem52 = null;
              $elem52 = new EndpointDetails();
              $xfer += $elem52->read($input);
              $this->endpoint_details []= $elem52;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->start_token !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->start_token));
      $output .= $this->start_token;
    }
    if ($this->end_token !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 2);
      $output .= pack('N', strlen($this->end_token));
      $output .= $this->end_token;
    }
    if ($this->endpoints !== null) {
      if (!is_array($this->endpoints)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 3);
      {
        $output .= pack('c', TType::STRING);
        $output .= strrev(pack('l', count($this->endpoints)));
        {
          foreach ($this->endpoints as $iter53)
          {
            $output .= pack('N', strlen($iter53));
            $output .= $iter53;
          }
        }
      }
    }
    if ($this->rpc_endpoints !== null) {
      if (!is_array($this->rpc_endpoints)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 4);
      {
        $output .= pack('c', TType::STRING);
        $output .= strrev(pack('l', count($this->rpc_endpoints)));
        {
          foreach ($this->rpc_endpoints as $iter54)
          {
            $output .= pack('N', strlen($iter54));
            $output .= $iter54;
          }
        }
      }
    }
    if ($this->endpoint_details !== null) {
      if (!is_array($this->endpoint_details)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 5);
      {
        $output .= pack('c', TType::STRUCT);
        $output .= strrev(pack('l', count($this->endpoint_details)));
        {
          foreach ($this->endpoint_details as $iter55)
          {
            $xfer += $iter55->write($output);
          }
        }
      }
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class AuthenticationRequest {
  static $_TSPEC;

  public $credentials = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'credentials',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['credentials'])) {
        $this->credentials = $vals['credentials'];
      }
    }
  }

  public function getName() {
    return 'AuthenticationRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->credentials = array();
            $_size56 = 0;
            $_ktype57 = 0;
            $_vtype58 = 0;
            $_ktype57 = unpack('c', $input->readAll(1));
            $_ktype57 = $_ktype57[1];
            $_vtype58 = unpack('c', $input->readAll(1));
            $_vtype58 = $_vtype58[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size56 = $val;
            for ($_i60 = 0; $_i60 < $_size56; ++$_i60)
            {
              $key61 = '';
              $val62 = '';
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $key61 = $input->readAll($len);
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $val62 = $input->readAll($len);
              $this->credentials[$key61] = $val62;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->credentials !== null) {
      if (!is_array($this->credentials)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::MAP);
      $output .= pack('n', 1);
      {
        $output .= pack('c', TType::STRING);
        $output .= pack('c', TType::STRING);
        $output .= strrev(pack('l', count($this->credentials)));
        {
          foreach ($this->credentials as $kiter63 => $viter64)
          {
            $output .= pack('N', strlen($kiter63));
            $output .= $kiter63;
            $output .= pack('N', strlen($viter64));
            $output .= $viter64;
          }
        }
      }
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class ColumnDef {
  static $_TSPEC;

  public $name = null;
  public $validation_class = null;
  public $index_type = null;
  public $index_name = null;
  public $index_options = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'validation_class',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'index_type',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'index_name',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'index_options',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['validation_class'])) {
        $this->validation_class = $vals['validation_class'];
      }
      if (isset($vals['index_type'])) {
        $this->index_type = $vals['index_type'];
      }
      if (isset($vals['index_name'])) {
        $this->index_name = $vals['index_name'];
      }
      if (isset($vals['index_options'])) {
        $this->index_options = $vals['index_options'];
      }
    }
  }

  public function getName() {
    return 'ColumnDef';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->name = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->validation_class = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->index_type = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->index_name = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->index_options = array();
            $_size65 = 0;
            $_ktype66 = 0;
            $_vtype67 = 0;
            $_ktype66 = unpack('c', $input->readAll(1));
            $_ktype66 = $_ktype66[1];
            $_vtype67 = unpack('c', $input->readAll(1));
            $_vtype67 = $_vtype67[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size65 = $val;
            for ($_i69 = 0; $_i69 < $_size65; ++$_i69)
            {
              $key70 = '';
              $val71 = '';
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $key70 = $input->readAll($len);
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $val71 = $input->readAll($len);
              $this->index_options[$key70] = $val71;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->name !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->name));
      $output .= $this->name;
    }
    if ($this->validation_class !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 2);
      $output .= pack('N', strlen($this->validation_class));
      $output .= $this->validation_class;
    }
    if ($this->index_type !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 3);
      $output .= pack('N', $this->index_type);
    }
    if ($this->index_name !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 4);
      $output .= pack('N', strlen($this->index_name));
      $output .= $this->index_name;
    }
    if ($this->index_options !== null) {
      if (!is_array($this->index_options)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::MAP);
      $output .= pack('n', 5);
      {
        $output .= pack('c', TType::STRING);
        $output .= pack('c', TType::STRING);
        $output .= strrev(pack('l', count($this->index_options)));
        {
          foreach ($this->index_options as $kiter72 => $viter73)
          {
            $output .= pack('N', strlen($kiter72));
            $output .= $kiter72;
            $output .= pack('N', strlen($viter73));
            $output .= $viter73;
          }
        }
      }
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class CfDef {
  static $_TSPEC;

  public $keyspace = null;
  public $name = null;
  public $column_type = "Standard";
  public $comparator_type = "BytesType";
  public $subcomparator_type = null;
  public $comment = null;
  public $row_cache_size = 0;
  public $key_cache_size = 200000;
  public $read_repair_chance = 1;
  public $column_metadata = null;
  public $gc_grace_seconds = null;
  public $default_validation_class = null;
  public $id = null;
  public $min_compaction_threshold = null;
  public $max_compaction_threshold = null;
  public $row_cache_save_period_in_seconds = null;
  public $key_cache_save_period_in_seconds = null;
  public $replicate_on_write = null;
  public $merge_shards_chance = null;
  public $key_validation_class = null;
  public $row_cache_provider = null;
  public $key_alias = null;
  public $compaction_strategy = null;
  public $compaction_strategy_options = null;
  public $row_cache_keys_to_save = null;
  public $compression_options = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keyspace',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'column_type',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'comparator_type',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'subcomparator_type',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'comment',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'row_cache_size',
          'type' => TType::DOUBLE,
          ),
        11 => array(
          'var' => 'key_cache_size',
          'type' => TType::DOUBLE,
          ),
        12 => array(
          'var' => 'read_repair_chance',
          'type' => TType::DOUBLE,
          ),
        13 => array(
          'var' => 'column_metadata',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'ColumnDef',
            ),
          ),
        14 => array(
          'var' => 'gc_grace_seconds',
          'type' => TType::I32,
          ),
        15 => array(
          'var' => 'default_validation_class',
          'type' => TType::STRING,
          ),
        16 => array(
          'var' => 'id',
          'type' => TType::I32,
          ),
        17 => array(
          'var' => 'min_compaction_threshold',
          'type' => TType::I32,
          ),
        18 => array(
          'var' => 'max_compaction_threshold',
          'type' => TType::I32,
          ),
        19 => array(
          'var' => 'row_cache_save_period_in_seconds',
          'type' => TType::I32,
          ),
        20 => array(
          'var' => 'key_cache_save_period_in_seconds',
          'type' => TType::I32,
          ),
        24 => array(
          'var' => 'replicate_on_write',
          'type' => TType::BOOL,
          ),
        25 => array(
          'var' => 'merge_shards_chance',
          'type' => TType::DOUBLE,
          ),
        26 => array(
          'var' => 'key_validation_class',
          'type' => TType::STRING,
          ),
        27 => array(
          'var' => 'row_cache_provider',
          'type' => TType::STRING,
          ),
        28 => array(
          'var' => 'key_alias',
          'type' => TType::STRING,
          ),
        29 => array(
          'var' => 'compaction_strategy',
          'type' => TType::STRING,
          ),
        30 => array(
          'var' => 'compaction_strategy_options',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        31 => array(
          'var' => 'row_cache_keys_to_save',
          'type' => TType::I32,
          ),
        32 => array(
          'var' => 'compression_options',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keyspace'])) {
        $this->keyspace = $vals['keyspace'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['column_type'])) {
        $this->column_type = $vals['column_type'];
      }
      if (isset($vals['comparator_type'])) {
        $this->comparator_type = $vals['comparator_type'];
      }
      if (isset($vals['subcomparator_type'])) {
        $this->subcomparator_type = $vals['subcomparator_type'];
      }
      if (isset($vals['comment'])) {
        $this->comment = $vals['comment'];
      }
      if (isset($vals['row_cache_size'])) {
        $this->row_cache_size = $vals['row_cache_size'];
      }
      if (isset($vals['key_cache_size'])) {
        $this->key_cache_size = $vals['key_cache_size'];
      }
      if (isset($vals['read_repair_chance'])) {
        $this->read_repair_chance = $vals['read_repair_chance'];
      }
      if (isset($vals['column_metadata'])) {
        $this->column_metadata = $vals['column_metadata'];
      }
      if (isset($vals['gc_grace_seconds'])) {
        $this->gc_grace_seconds = $vals['gc_grace_seconds'];
      }
      if (isset($vals['default_validation_class'])) {
        $this->default_validation_class = $vals['default_validation_class'];
      }
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['min_compaction_threshold'])) {
        $this->min_compaction_threshold = $vals['min_compaction_threshold'];
      }
      if (isset($vals['max_compaction_threshold'])) {
        $this->max_compaction_threshold = $vals['max_compaction_threshold'];
      }
      if (isset($vals['row_cache_save_period_in_seconds'])) {
        $this->row_cache_save_period_in_seconds = $vals['row_cache_save_period_in_seconds'];
      }
      if (isset($vals['key_cache_save_period_in_seconds'])) {
        $this->key_cache_save_period_in_seconds = $vals['key_cache_save_period_in_seconds'];
      }
      if (isset($vals['replicate_on_write'])) {
        $this->replicate_on_write = $vals['replicate_on_write'];
      }
      if (isset($vals['merge_shards_chance'])) {
        $this->merge_shards_chance = $vals['merge_shards_chance'];
      }
      if (isset($vals['key_validation_class'])) {
        $this->key_validation_class = $vals['key_validation_class'];
      }
      if (isset($vals['row_cache_provider'])) {
        $this->row_cache_provider = $vals['row_cache_provider'];
      }
      if (isset($vals['key_alias'])) {
        $this->key_alias = $vals['key_alias'];
      }
      if (isset($vals['compaction_strategy'])) {
        $this->compaction_strategy = $vals['compaction_strategy'];
      }
      if (isset($vals['compaction_strategy_options'])) {
        $this->compaction_strategy_options = $vals['compaction_strategy_options'];
      }
      if (isset($vals['row_cache_keys_to_save'])) {
        $this->row_cache_keys_to_save = $vals['row_cache_keys_to_save'];
      }
      if (isset($vals['compression_options'])) {
        $this->compression_options = $vals['compression_options'];
      }
    }
  }

  public function getName() {
    return 'CfDef';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->keyspace = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->name = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->column_type = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->comparator_type = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->subcomparator_type = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->comment = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 9:
          if ($ftype == TType::DOUBLE) {
            $arr = unpack('d', strrev($input->readAll(8)));
            $this->row_cache_size = $arr[1];
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 11:
          if ($ftype == TType::DOUBLE) {
            $arr = unpack('d', strrev($input->readAll(8)));
            $this->key_cache_size = $arr[1];
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 12:
          if ($ftype == TType::DOUBLE) {
            $arr = unpack('d', strrev($input->readAll(8)));
            $this->read_repair_chance = $arr[1];
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 13:
          if ($ftype == TType::LST) {
            $this->column_metadata = array();
            $_size74 = 0;
            $_etype77 = unpack('c', $input->readAll(1));
            $_etype77 = $_etype77[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size74 = $val;
            for ($_i78 = 0; $_i78 < $_size74; ++$_i78)
            {
              $elem79 = null;
              $elem79 = new ColumnDef();
              $xfer += $elem79->read($input);
              $this->column_metadata []= $elem79;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 14:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->gc_grace_seconds = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 15:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->default_validation_class = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 16:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->id = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 17:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->min_compaction_threshold = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 18:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->max_compaction_threshold = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 19:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->row_cache_save_period_in_seconds = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 20:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->key_cache_save_period_in_seconds = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 24:
          if ($ftype == TType::BOOL) {
            $this->replicate_on_write = unpack('c', $input->readAll(1));
            $this->replicate_on_write = (bool)$this->replicate_on_write[1];
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 25:
          if ($ftype == TType::DOUBLE) {
            $arr = unpack('d', strrev($input->readAll(8)));
            $this->merge_shards_chance = $arr[1];
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 26:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->key_validation_class = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 27:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->row_cache_provider = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 28:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->key_alias = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 29:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->compaction_strategy = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 30:
          if ($ftype == TType::MAP) {
            $this->compaction_strategy_options = array();
            $_size80 = 0;
            $_ktype81 = 0;
            $_vtype82 = 0;
            $_ktype81 = unpack('c', $input->readAll(1));
            $_ktype81 = $_ktype81[1];
            $_vtype82 = unpack('c', $input->readAll(1));
            $_vtype82 = $_vtype82[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size80 = $val;
            for ($_i84 = 0; $_i84 < $_size80; ++$_i84)
            {
              $key85 = '';
              $val86 = '';
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $key85 = $input->readAll($len);
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $val86 = $input->readAll($len);
              $this->compaction_strategy_options[$key85] = $val86;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 31:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->row_cache_keys_to_save = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 32:
          if ($ftype == TType::MAP) {
            $this->compression_options = array();
            $_size87 = 0;
            $_ktype88 = 0;
            $_vtype89 = 0;
            $_ktype88 = unpack('c', $input->readAll(1));
            $_ktype88 = $_ktype88[1];
            $_vtype89 = unpack('c', $input->readAll(1));
            $_vtype89 = $_vtype89[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size87 = $val;
            for ($_i91 = 0; $_i91 < $_size87; ++$_i91)
            {
              $key92 = '';
              $val93 = '';
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $key92 = $input->readAll($len);
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $val93 = $input->readAll($len);
              $this->compression_options[$key92] = $val93;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->keyspace !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->keyspace));
      $output .= $this->keyspace;
    }
    if ($this->name !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 2);
      $output .= pack('N', strlen($this->name));
      $output .= $this->name;
    }
    if ($this->column_type !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 3);
      $output .= pack('N', strlen($this->column_type));
      $output .= $this->column_type;
    }
    if ($this->comparator_type !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 5);
      $output .= pack('N', strlen($this->comparator_type));
      $output .= $this->comparator_type;
    }
    if ($this->subcomparator_type !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 6);
      $output .= pack('N', strlen($this->subcomparator_type));
      $output .= $this->subcomparator_type;
    }
    if ($this->comment !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 8);
      $output .= pack('N', strlen($this->comment));
      $output .= $this->comment;
    }
    if ($this->row_cache_size !== null) {
      $output .= pack('c', TType::DOUBLE);
      $output .= pack('n', 9);
      $output .= strrev(pack('d', $this->row_cache_size));
    }
    if ($this->key_cache_size !== null) {
      $output .= pack('c', TType::DOUBLE);
      $output .= pack('n', 11);
      $output .= strrev(pack('d', $this->key_cache_size));
    }
    if ($this->read_repair_chance !== null) {
      $output .= pack('c', TType::DOUBLE);
      $output .= pack('n', 12);
      $output .= strrev(pack('d', $this->read_repair_chance));
    }
    if ($this->column_metadata !== null) {
      if (!is_array($this->column_metadata)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 13);
      {
        $output .= pack('c', TType::STRUCT);
        $output .= strrev(pack('l', count($this->column_metadata)));
        {
          foreach ($this->column_metadata as $iter94)
          {
            $xfer += $iter94->write($output);
          }
        }
      }
    }
    if ($this->gc_grace_seconds !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 14);
      $output .= pack('N', $this->gc_grace_seconds);
    }
    if ($this->default_validation_class !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 15);
      $output .= pack('N', strlen($this->default_validation_class));
      $output .= $this->default_validation_class;
    }
    if ($this->id !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 16);
      $output .= pack('N', $this->id);
    }
    if ($this->min_compaction_threshold !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 17);
      $output .= pack('N', $this->min_compaction_threshold);
    }
    if ($this->max_compaction_threshold !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 18);
      $output .= pack('N', $this->max_compaction_threshold);
    }
    if ($this->row_cache_save_period_in_seconds !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 19);
      $output .= pack('N', $this->row_cache_save_period_in_seconds);
    }
    if ($this->key_cache_save_period_in_seconds !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 20);
      $output .= pack('N', $this->key_cache_save_period_in_seconds);
    }
    if ($this->replicate_on_write !== null) {
      $output .= pack('c', TType::BOOL);
      $output .= pack('n', 24);
      $output .= pack('c', $this->replicate_on_write ? 1 : 0);
    }
    if ($this->merge_shards_chance !== null) {
      $output .= pack('c', TType::DOUBLE);
      $output .= pack('n', 25);
      $output .= strrev(pack('d', $this->merge_shards_chance));
    }
    if ($this->key_validation_class !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 26);
      $output .= pack('N', strlen($this->key_validation_class));
      $output .= $this->key_validation_class;
    }
    if ($this->row_cache_provider !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 27);
      $output .= pack('N', strlen($this->row_cache_provider));
      $output .= $this->row_cache_provider;
    }
    if ($this->key_alias !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 28);
      $output .= pack('N', strlen($this->key_alias));
      $output .= $this->key_alias;
    }
    if ($this->compaction_strategy !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 29);
      $output .= pack('N', strlen($this->compaction_strategy));
      $output .= $this->compaction_strategy;
    }
    if ($this->compaction_strategy_options !== null) {
      if (!is_array($this->compaction_strategy_options)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::MAP);
      $output .= pack('n', 30);
      {
        $output .= pack('c', TType::STRING);
        $output .= pack('c', TType::STRING);
        $output .= strrev(pack('l', count($this->compaction_strategy_options)));
        {
          foreach ($this->compaction_strategy_options as $kiter95 => $viter96)
          {
            $output .= pack('N', strlen($kiter95));
            $output .= $kiter95;
            $output .= pack('N', strlen($viter96));
            $output .= $viter96;
          }
        }
      }
    }
    if ($this->row_cache_keys_to_save !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 31);
      $output .= pack('N', $this->row_cache_keys_to_save);
    }
    if ($this->compression_options !== null) {
      if (!is_array($this->compression_options)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::MAP);
      $output .= pack('n', 32);
      {
        $output .= pack('c', TType::STRING);
        $output .= pack('c', TType::STRING);
        $output .= strrev(pack('l', count($this->compression_options)));
        {
          foreach ($this->compression_options as $kiter97 => $viter98)
          {
            $output .= pack('N', strlen($kiter97));
            $output .= $kiter97;
            $output .= pack('N', strlen($viter98));
            $output .= $viter98;
          }
        }
      }
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class KsDef {
  static $_TSPEC;

  public $name = null;
  public $strategy_class = null;
  public $strategy_options = null;
  public $replication_factor = null;
  public $cf_defs = null;
  public $durable_writes = true;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'strategy_class',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'strategy_options',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'replication_factor',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'cf_defs',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'CfDef',
            ),
          ),
        6 => array(
          'var' => 'durable_writes',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['strategy_class'])) {
        $this->strategy_class = $vals['strategy_class'];
      }
      if (isset($vals['strategy_options'])) {
        $this->strategy_options = $vals['strategy_options'];
      }
      if (isset($vals['replication_factor'])) {
        $this->replication_factor = $vals['replication_factor'];
      }
      if (isset($vals['cf_defs'])) {
        $this->cf_defs = $vals['cf_defs'];
      }
      if (isset($vals['durable_writes'])) {
        $this->durable_writes = $vals['durable_writes'];
      }
    }
  }

  public function getName() {
    return 'KsDef';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->name = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->strategy_class = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->strategy_options = array();
            $_size99 = 0;
            $_ktype100 = 0;
            $_vtype101 = 0;
            $_ktype100 = unpack('c', $input->readAll(1));
            $_ktype100 = $_ktype100[1];
            $_vtype101 = unpack('c', $input->readAll(1));
            $_vtype101 = $_vtype101[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size99 = $val;
            for ($_i103 = 0; $_i103 < $_size99; ++$_i103)
            {
              $key104 = '';
              $val105 = '';
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $key104 = $input->readAll($len);
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $val105 = $input->readAll($len);
              $this->strategy_options[$key104] = $val105;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->replication_factor = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->cf_defs = array();
            $_size106 = 0;
            $_etype109 = unpack('c', $input->readAll(1));
            $_etype109 = $_etype109[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size106 = $val;
            for ($_i110 = 0; $_i110 < $_size106; ++$_i110)
            {
              $elem111 = null;
              $elem111 = new CfDef();
              $xfer += $elem111->read($input);
              $this->cf_defs []= $elem111;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 6:
          if ($ftype == TType::BOOL) {
            $this->durable_writes = unpack('c', $input->readAll(1));
            $this->durable_writes = (bool)$this->durable_writes[1];
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->name !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->name));
      $output .= $this->name;
    }
    if ($this->strategy_class !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 2);
      $output .= pack('N', strlen($this->strategy_class));
      $output .= $this->strategy_class;
    }
    if ($this->strategy_options !== null) {
      if (!is_array($this->strategy_options)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::MAP);
      $output .= pack('n', 3);
      {
        $output .= pack('c', TType::STRING);
        $output .= pack('c', TType::STRING);
        $output .= strrev(pack('l', count($this->strategy_options)));
        {
          foreach ($this->strategy_options as $kiter112 => $viter113)
          {
            $output .= pack('N', strlen($kiter112));
            $output .= $kiter112;
            $output .= pack('N', strlen($viter113));
            $output .= $viter113;
          }
        }
      }
    }
    if ($this->replication_factor !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 4);
      $output .= pack('N', $this->replication_factor);
    }
    if ($this->cf_defs !== null) {
      if (!is_array($this->cf_defs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 5);
      {
        $output .= pack('c', TType::STRUCT);
        $output .= strrev(pack('l', count($this->cf_defs)));
        {
          foreach ($this->cf_defs as $iter114)
          {
            $xfer += $iter114->write($output);
          }
        }
      }
    }
    if ($this->durable_writes !== null) {
      $output .= pack('c', TType::BOOL);
      $output .= pack('n', 6);
      $output .= pack('c', $this->durable_writes ? 1 : 0);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class CqlRow {
  static $_TSPEC;

  public $key = null;
  public $columns = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'Column',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['key'])) {
        $this->key = $vals['key'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
    }
  }

  public function getName() {
    return 'CqlRow';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->key = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size115 = 0;
            $_etype118 = unpack('c', $input->readAll(1));
            $_etype118 = $_etype118[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size115 = $val;
            for ($_i119 = 0; $_i119 < $_size115; ++$_i119)
            {
              $elem120 = null;
              $elem120 = new Column();
              $xfer += $elem120->read($input);
              $this->columns []= $elem120;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->key !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 1);
      $output .= pack('N', strlen($this->key));
      $output .= $this->key;
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 2);
      {
        $output .= pack('c', TType::STRUCT);
        $output .= strrev(pack('l', count($this->columns)));
        {
          foreach ($this->columns as $iter121)
          {
            $xfer += $iter121->write($output);
          }
        }
      }
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class CqlMetadata {
  static $_TSPEC;

  public $name_types = null;
  public $value_types = null;
  public $default_name_type = null;
  public $default_value_type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name_types',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'value_types',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'default_name_type',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'default_value_type',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name_types'])) {
        $this->name_types = $vals['name_types'];
      }
      if (isset($vals['value_types'])) {
        $this->value_types = $vals['value_types'];
      }
      if (isset($vals['default_name_type'])) {
        $this->default_name_type = $vals['default_name_type'];
      }
      if (isset($vals['default_value_type'])) {
        $this->default_value_type = $vals['default_value_type'];
      }
    }
  }

  public function getName() {
    return 'CqlMetadata';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->name_types = array();
            $_size122 = 0;
            $_ktype123 = 0;
            $_vtype124 = 0;
            $_ktype123 = unpack('c', $input->readAll(1));
            $_ktype123 = $_ktype123[1];
            $_vtype124 = unpack('c', $input->readAll(1));
            $_vtype124 = $_vtype124[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size122 = $val;
            for ($_i126 = 0; $_i126 < $_size122; ++$_i126)
            {
              $key127 = '';
              $val128 = '';
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $key127 = $input->readAll($len);
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $val128 = $input->readAll($len);
              $this->name_types[$key127] = $val128;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->value_types = array();
            $_size129 = 0;
            $_ktype130 = 0;
            $_vtype131 = 0;
            $_ktype130 = unpack('c', $input->readAll(1));
            $_ktype130 = $_ktype130[1];
            $_vtype131 = unpack('c', $input->readAll(1));
            $_vtype131 = $_vtype131[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size129 = $val;
            for ($_i133 = 0; $_i133 < $_size129; ++$_i133)
            {
              $key134 = '';
              $val135 = '';
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $key134 = $input->readAll($len);
              $len = unpack('N', $input->readAll(4));
              $len = $len[1];
              if ($len > 0x7fffffff) {
                $len = 0 - (($len - 1) ^ 0xffffffff);
              }
              $val135 = $input->readAll($len);
              $this->value_types[$key134] = $val135;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->default_name_type = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $len = unpack('N', $input->readAll(4));
            $len = $len[1];
            if ($len > 0x7fffffff) {
              $len = 0 - (($len - 1) ^ 0xffffffff);
            }
            $this->default_value_type = $input->readAll($len);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->name_types !== null) {
      if (!is_array($this->name_types)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::MAP);
      $output .= pack('n', 1);
      {
        $output .= pack('c', TType::STRING);
        $output .= pack('c', TType::STRING);
        $output .= strrev(pack('l', count($this->name_types)));
        {
          foreach ($this->name_types as $kiter136 => $viter137)
          {
            $output .= pack('N', strlen($kiter136));
            $output .= $kiter136;
            $output .= pack('N', strlen($viter137));
            $output .= $viter137;
          }
        }
      }
    }
    if ($this->value_types !== null) {
      if (!is_array($this->value_types)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::MAP);
      $output .= pack('n', 2);
      {
        $output .= pack('c', TType::STRING);
        $output .= pack('c', TType::STRING);
        $output .= strrev(pack('l', count($this->value_types)));
        {
          foreach ($this->value_types as $kiter138 => $viter139)
          {
            $output .= pack('N', strlen($kiter138));
            $output .= $kiter138;
            $output .= pack('N', strlen($viter139));
            $output .= $viter139;
          }
        }
      }
    }
    if ($this->default_name_type !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 3);
      $output .= pack('N', strlen($this->default_name_type));
      $output .= $this->default_name_type;
    }
    if ($this->default_value_type !== null) {
      $output .= pack('c', TType::STRING);
      $output .= pack('n', 4);
      $output .= pack('N', strlen($this->default_value_type));
      $output .= $this->default_value_type;
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

class CqlResult {
  static $_TSPEC;

  public $type = null;
  public $rows = null;
  public $num = null;
  public $schema = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'rows',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'CqlRow',
            ),
          ),
        3 => array(
          'var' => 'num',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'schema',
          'type' => TType::STRUCT,
          'class' => 'CqlMetadata',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['rows'])) {
        $this->rows = $vals['rows'];
      }
      if (isset($vals['num'])) {
        $this->num = $vals['num'];
      }
      if (isset($vals['schema'])) {
        $this->schema = $vals['schema'];
      }
    }
  }

  public function getName() {
    return 'CqlResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    while (true)
    {
      $ftype = unpack('c', $input->readAll(1));
      $ftype = $ftype[1];
      if ($ftype == TType::STOP) {
        break;
      }
      $val = unpack('n', $input->readAll(2));
      $val = $val[1];
      if ($val > 0x7fff) {
        $val = 0 - (($val - 1) ^ 0xffff);
      }
      $fid = $val;
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->type = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->rows = array();
            $_size140 = 0;
            $_etype143 = unpack('c', $input->readAll(1));
            $_etype143 = $_etype143[1];
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $_size140 = $val;
            for ($_i144 = 0; $_i144 < $_size140; ++$_i144)
            {
              $elem145 = null;
              $elem145 = new CqlRow();
              $xfer += $elem145->read($input);
              $this->rows []= $elem145;
            }
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $val = unpack('N', $input->readAll(4));
            $val = $val[1];
            if ($val > 0x7fffffff) {
              $val = 0 - (($val - 1) ^ 0xffffffff);
            }
            $this->num = $val;
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->schema = new CqlMetadata();
            $xfer += $this->schema->read($input);
          } else {
            $xfer += TProtocol::skipBinary($input, $ftype);
          }
          break;
        default:
          $xfer += TProtocol::skipBinary($input, $ftype);
          break;
      }
    }
    return $xfer;
  }

  public function write(&$output) {
    $xfer = 0;
    if ($this->type !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 1);
      $output .= pack('N', $this->type);
    }
    if ($this->rows !== null) {
      if (!is_array($this->rows)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::LST);
      $output .= pack('n', 2);
      {
        $output .= pack('c', TType::STRUCT);
        $output .= strrev(pack('l', count($this->rows)));
        {
          foreach ($this->rows as $iter146)
          {
            $xfer += $iter146->write($output);
          }
        }
      }
    }
    if ($this->num !== null) {
      $output .= pack('c', TType::I32);
      $output .= pack('n', 3);
      $output .= pack('N', $this->num);
    }
    if ($this->schema !== null) {
      if (!is_object($this->schema)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $output .= pack('c', TType::STRUCT);
      $output .= pack('n', 4);
      $xfer += $this->schema->write($output);
    }
    $output .= pack('c', TType::STOP);
    return $xfer;
  }

}

?>

