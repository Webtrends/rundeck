portfolio-harness-system {
    include "common"

    portfolio {
        http-port=8080

        monitoring {
            #Monitoring
            application.name = "Portfolio Harness"
            # the prefix to append metrics being sent to graphite
            metric.prefix = <%= node['wt_monitoring']['metric_prefix'] %>
            # Are we monitoring at all
            enabled = <%= node['wt_monitoring']['monitoring_enabled'] %>
            # should we publish to jmx
            jmx.enabled = <%= node['wt_monitoring']['jmx_enabled'] %>
            # the prefix to append metrics being sent to graphite
            jmx.port = <%= @jmx_port %>
            # Are metrics going to graphite
            graphite.enabled = <%= @graphite_enabled %>
            # What is the host of graphite
            graphite.host=<%= node[:wt_monitoring][:graphite_server] %>
            # What port is graphite listening on
            graphite.port=<%= node[:wt_monitoring][:graphite_port] %>
            # How often (minutes) should we flush metrics to graphite
            graphite.interval=<%= @graphite_interval %>
            # Should we include the JVM metrics when sending to graphite
            graphite.vmmetrics=<%= @graphite_vmmetrics %>
            # This is a regular expression for which metrics should be sent on to graphite. All metrics are still exposed via JMX or the metrics endpoint
            graphite.regex=<%= @graphite_regex %>

            # Are health checks enabled
            healthcheck.enabled=<%= node['wt_monitoring']['healthcheck_enabled'] %>
        }
    }

    akka {
        event-handlers = ["com.webtrends.portfolio.logging.Logger"]
        loglevel=DEBUG
        log-config-on-start = off
        receive=on

        debug {
            receive = on
            autoreceive = on
            lifecycle = on
            event-stream = on
        }

        actor {
            serializers {
                proto = "akka.remote.serialization.ProtobufSerializer"
                java = "akka.serialization.JavaSerializer"
                bytes = "akka.serialization.ByteArraySerializer"
                blank = "akka.serialization.NullSerializer"
            }

            serialization-bindings {
                "[B" = bytes
            }

            provider = "akka.remote.RemoteActorRefProvider"
            deployment {
                /harness/tcpprocessor {
                    router = smallest-mailbox
                    nr-of-instances = 5
                }
                #/0mq-processor {
                #    router = smallest-mailbox
                #    nr-of-instances = 5
                #}
            }

            debug {
                autorecieve=on
            }
        }
        remote {
            log-sent-messages = on
            log-received-messages = on
            transport = "akka.remote.netty.NettyRemoteTransport"

            netty {
                hostname = "<%= node[:fqdn] %>"
                port = 2552
                write-buffer-high-water-mark = 1048576b
                write-buffer-low-water-mark = 0b
                send-buffer-size = 1048576b
                receive-buffer-size = 1048576b
            }
        }

        io {
            # In bytes, the size of the shared read buffer. In the span 0b..2GiB.
            read-buffer-size = 32KiB
            # Specifies how many ops are done between every descriptor selection
            select-interval = 100
            # Number of connections that are allowed in the backlog.
            # 0 or negative means that the platform default will be used.
            default-backlog = 1000
        }
    }

    spray {
        can {
            server {
                request-timeout=5s
            }
        }
    }
 }
